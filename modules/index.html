<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="" />
	  <meta name="viewport" content="width=device-width, user-scalable=no">
	
    <link href='http://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic,700italic|Nova+Square' rel='stylesheet' type='text/css'>
    <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

    <title>DH Bridge</title>

    <link href="../stylesheets/codes.css" rel="stylesheet" type="text/css" />
    <link href="../stylesheets/style.css" rel="stylesheet" type="text/css" />
  </head>

  <body class="modules modules_index">
    <!-- HEADER -->
        <header>
				<div class="wrap">
	    <h1 id="project_title">DH Bridge</h1>
	    <h2 class="tag">Encouraging Computational Thinking and Digital Skills in the Humanities</h2>

	    <nav id="pages">
	    	<a href="/">Computational Thinking</a>
	    	<a href="http://dhbridge.org">About DH Bridge</a>
	    </nav>
	</div>
        </header> 
        <!-- MAIN CONTENT -->
        <div class="wrap">
            <div id="main">
              <article>
                		<section id="sidebar">
			<h2>Modules</h2>
			<a href="/modules/installation.html">Installation Instructions</a>

			<ol>
			<li><a href="/modules/module01.html">Working with your Computer</a></li>
			<li><a href="/modules/module02.html">Thinking about Data</a></li>
			<li><a href="/modules/module03.html">Getting Data</a></li>
			<li><a href="/modules/module04.html">Working with the API</a></li>
			<li><a href="/modules/module05.html">Writing Script Files</a></li>
			<li><a href="/modules/module06.html">Phase Two</a></li>
			<li><a href="/modules/module07.html">Using Functions and Loops</a></li>
			<li><a href="/modules/module08.html">Using While-Loops</a></li>
			<li><a href="/modules/module09.html">Writing Results to File</a></li>
			<li><a href="/modules/module10.html">Working with Local Data</a></li>
			<li><a href="/modules/module11.html">Analyzing the Data (Part 1)</a></li>
			<li><a href="/modules/module12.html">Analyzing the Data (Part 2)</a></li>
			<li><a href="/modules/module13.html">Saving Results to a File</a></li>
			<li><a href="/modules/module14.html">Next Steps</a></li>
			</ol>
		</section>

                <section id="content">
                  
  <h3><a href="/modules/coaches-guide.html">Overview for Coaches</a></h3>
  <!-- use article.summary(250) if you have Nokogiri available to show just
       the first 250 characters -->
  <p>Welcome to being a coach for a DH Bridge workshop! This document will orient you to the goals and objectives for the day (and beyond), how the tutorials have been scaffolded, and the places where your expertise will be needed to guide participants. </p>

<h3 id="goals-and-objectives">Goals and Objectives</h3>

<p>Coaches will need to: </p>

<ol>
  <li>Be mindful of the obstacles that make it difficult for persons from underrepresented groups to learn to code, and be respectful of particpants' efforts to learn.</li>
  <li>Foster collegial interaction between participants in their group, and encourage participants to collaborate and help each other when possible. </li>
  <li>Facilitate participants' forays into computational thinking by highlighting the relationships between data, content, and questions.</li>
  <li>Encourage participants to avoid self-deprecating/apologetic language (I'm not sure if I'm smart enough, I'm not very good with technology, etc.). </li>
</ol>

<h3 id="tips-for-the-day">Tips for the Day</h3>

<ol>
  <li>Not all questions have solutions, errors will happen, and that's ok. Talk through participants' results, and move them toward forming their own questions to troubleshoot.</li>
  <li>If a group is progressing quickly through the tutorials, have them explain back what the different lines of code are doing and/or complete the Bonus Challenges on the relevant tutorials. </li>
  <li>There shouldn't be any copying/pasting of the code.</li>
  <li>Only 1 folder should be used for the entire workshop.</li>
  <li>Ask before taking over a participant's machine to demonstrate or fix a problem, and only do so if absolutely necessary. </li>
  <li>To make things easy on everyone, the following terminology will be used consistently throughout the day:</li>
</ol>

<p>Terminal and Powershell = Terminal
Directories and Folders = Folders 
For Mac/Windows term translation: <a href="http://www.dummies.com/how-to/content/comparing-common-windows-terms-with-mac-terms.html">http://www.dummies.com/how-to/content/comparing-common-windows-terms-with-mac-terms.html</a></p>

<ol>
  <li>Capitalization is crucial in Windows Powershell, so if you see participants running into problems it's always a good idea to check there. </li>
</ol>

<h3 id="full-day-schedule">Full Day Schedule</h3>

<p>Note: the timeblocks are suggestions and will depend on the progress of your group. The first half of the day is primarily concerned with introducing thinking computationally: how a computer processes information locally and with other computers. The second half of the day builds on this foundation to address computational thinking about humanities data: how to utilize computation to ask questions and work with the kinds of data that interest humanities scholars.</p>

<p><strong>9:30-10:20a</strong> Welcome and Setting Up the Learning Environment: goals and objectives for the day, introductions within small groups. Coaches' Project Demonstrations: current projects and problems</p>

<p>10 Minute Break</p>

<p><strong>10:30-Noon:</strong> Modules 1-5</p>

<p>LUNCH</p>

<p><strong>1:00-2:30p:</strong> Modules 6 - 8</p>

<p>10 Minute Break</p>

<p><strong>2:40-4:00p:</strong> Modules 9 - 11</p>

<p><strong>4:00-5:00p:</strong> Modules 12 - 13</p>

<p><strong>5:00-5:30:</strong> Wrapup (recap the day and tips for continued learning)</p>

<p><strong>5:30:</strong> Decompressing and socializing</p>

<h3 id="tutorial-modules">Tutorial Modules</h3>

<ul>
  <li><a href="#installation">Installation</a></li>
  <li><a href="#one">Module 1</a></li>
  <li><a href="#two">Module 2</a></li>
  <li><a href="#three">Module 3</a></li>
  <li><a href="#four">Module 4</a></li>
  <li><a href="#five">Module 5</a></li>
  <li><a href="#six">Module 6</a></li>
  <li><a href="#seven">Module 7</a></li>
  <li><a href="#eight">Module 8</a></li>
  <li><a href="#nine">Module 9</a></li>
  <li><a href="#ten">Module 10</a></li>
  <li><a href="#eleven">Module 11</a></li>
  <li><a href="#twelve">Module 12</a></li>
  <li><a href="#thirteen">Module 13</a></li>
</ul>

<h3 id="installation">Installation</h3>

<p>Check to make sure that participants have the following installed and ready to go:</p>

<ol>
  <li>Python 2.7</li>
  <li><code>pip</code></li>
  <li>Text Editor: work with participants to set TextWrangler as the default text editor for Mac users. It's not an issue for Windows users because the commands specify starting Notepad++ each time. </li>
  <li>Chrome browser</li>
</ol>

<p>If possible, please have participants pin the text editor and Chrome to their Dock (Mac)/Taskbar (Windows), or at least have them easily accessible. </p>

<h3 id="one">One</h3>

<p>(To be done with the full group)</p>

<p><strong>Learning Checks:</strong></p>

<ol>
  <li>After your group members have all created their "dhb_awesome" folder have them find where it lives on their computer through Finder/My Computer. Have them compare the directory path with what they did in Terminal to ensure they can see that they are creating files and folders on their local machine.   </li>
</ol>

<h3 id="two">Two</h3>
<p>Start with the DPLA interface in the browser and search for "cooking". Have your group read what's going on in the URL. Filter the number of items displayed using the GUI's filters. How did the URL change? What's the syntax?  </p>

<p><strong>Learning Checks:</strong></p>

<ol>
  <li>Have them talk through the API request URL to reinforce understanding of the structure of the request.</li>
  <li>Review how JSON stores data items as objects and how it displays those objects.</li>
</ol>

<h3 id="three">Three</h3>
<p>Questions to keep in mind throughout the module:</p>

<p><strong>Learning Checks:</strong> </p>

<ol>
  <li>Make sure participants are clear on difference between Python Interactive Shell and Terminal.</li>
  <li>Terminology check: string, variable, array/list</li>
</ol>

<h3 id="four">Four</h3>
<p>Questions to keep in mind throughout the module:</p>

<p><strong>Learning Checks:</strong></p>

<ol>
  <li>Constructing additional queries: highlight the questions that would motivate the choice of different commands and filtering of results.</li>
  <li>See if there are any general questions about APIs and the documentation used in the module. </li>
</ol>

<h3 id="five">Five</h3>

<p><strong>Learning Checks: programming languages and libraries</strong></p>

<ol>
  <li>
    <p><strong>Mapping Exercise #1:</strong> have participants diagram the following, similar to the API exercise from earlier in the day:
-High-level programming languages (like Python) enable you to write commands for your computer in something that approximates English. Those commands are then translated down to machine language, executed by the hardware, and the results are translated back to generate the desired output. Your computer is constantly processing commands from the applications on your machine in multiple programming languages. Just like those applications, you can use the terminal interface to send commands to your computer.
-Discuss everyone's diagrams and make sure the concepts are clear.</p>
  </li>
  <li>
    <p><strong>Mapping Exercise #2:</strong> have participants diagram the following, similar to the API exercise from earlier in the day:
-A Python module or library is a bundle of code, including variables and functions (defined processes), that does a particular task. Many Python modules already exist out in the world, ready to be used, and new ones are developed by programmers all the time. Python scripts, which combine these modules with additional python commands, give the computer new, and more complicated, tasks that can be completed.
-Discuss everyone's diagrams and make sure the concepts are clear.</p>
  </li>
</ol>

<h3 id="six">Six</h3>

<p>Before your group jumps into the code-heavy part of the module, start off with the quick review of how script files should be organized. There will also be a handout for participants to reference as they continue through the modules. Participants may be tempted to gloss over this part, but make sure they take the time to get the format down. 
1. load libraries
2. set variables to be used throughout the script
3. define all functions
4. calls/commands to execute the functions</p>

<p>Terminology related to functions: from now on the tutorials will heavily use new phrases to describe how the functions work in relation to the data. These phrases are part of programming vernacular, and so they're not jarring to participants, here are some basic definitions to maintain consistency:
1. call: to execute 
2. declare/set: create a new function
3. pass: to run data through the function/loop</p>

<p><strong>Learning Checks:</strong>
1. Have a quick discussion about the merits of commenting out versus deleting lines
2. Verify that participants understand setting variables and how they can hold lists (an empty list so far).
2. Group challenge "for loop" exercise: check that the participants have a solid grasp on the function and purpose of a "for loop".</p>

<h3 id="seven">Seven</h3>

<p><strong>Learning Checks:</strong> 
1. Review and explain in a group discussion: how functions can be combined to solve problems, with the example of the two functions written so far and how they work together.
2. Review what "append" does.
3. Group challenge: talk through the functionality and uses for a "for loop"</p>

<h3 id="eight">Eight</h3>

<p><strong>Learning Checks:</strong> 
1. Group challenge: along with talking through how a "while loop" works, also review why the "while loop" is added into the function where it is. </p>

<h3 id="nine">Nine</h3>
<p>Questions for the participants to discuss/keep in mind throughout the module:
1. </p>

<p><strong>Learning Checks:</strong>
1. The value of working locally: writing the search results to a JSON file gives the flexibility for working with a large collection of files on a local machine without having to constantly hit the DPLA (or any other API servers) and to find patterns that we could not find using the online interface for the DPLA's holdings.
2. When to use "append": writing inside a loop, which allows the comupter to add the information it grabs to the end of the file rather than overwriting what's there each time. </p>

<h3 id="ten">Ten</h3>
<p>Questions for the participants to discuss/keep in mind throughout the module: 
1. Are there other data fields to include that would help address the research question? 
2. What other research questions can you ask of this data?</p>

<p><strong>Learning Checks:</strong>
1. Dealing with the realities of messy data: pristine datasets are extremely rare. In our example, the "cooking" data features many items that don't have information for the three fields that we're focusing on. 
2. Open your "text_results.txt" file in TextWrangler/Notepad++ and scroll through what was saved. What do you notice? What information is/isn't there? What kinds of hypotheses can you make based on these results?</p>

<p>**We anticipate this will be as far as participants can get in one day without getting too frustrated or burned out. If that's the case, encourage them to talk through what they've already done, clarify parts that are still mysterious/confusing, and/or go back to the earlier modules and work through with different search terms and parameters. They can also do the activity posed as a Learning Check in Module 13.</p>

<h3 id="eleven">Eleven</h3>
<p>Questions for the participants to discuss/keep in mind throughout the module:
1. How is the script parsing the text data? 
2. What are the benefits and limitations of breaking the data into chunks in this way?
3. How would you speak to how you as the researcher have shaped this dataset?</p>

<p><strong>Learning Checks:</strong> 
1. Words, sentences, tokens: what is a token? 
2. Collocations and concordances: what are they doing? what analytical value does each have for the research question at hand and for your own work? </p>

<h3 id="twelve">Twelve</h3>
<p>Questions for the participants to discuss/keep in mind throughout the module: 
1. How does the results generated by the text mining script compare to your own hypotheses? 
2. What kinds of research projects and questions benefit from this approach? </p>

<p><strong>Learning Checks:</strong>
1. Stopwords: what makes up these lists? how does one need to account for different stopwords based on the research at hand, language, corpus, etc.?
2. Encourage participants to checkout the documentation for <a href="http://www.nltk.org/">NLTK</a> to get a better sense of what else it can do.  </p>

<h3 id="thirteen">Thirteen</h3>

<p><strong>Learning Checks:</strong>
1. Have participants pull out their diagrams of Terminal, API, and programming languages and make any necessary revisions based on what they've learned throughout the day. </p>


  <h3><a href="/modules/module08.html">Looping through the Pages</a></h3>
  <!-- use article.summary(250) if you have Nokogiri available to show just
       the first 250 characters -->
  <p>In this module, we will learn:</p>

<ol>
  <li>To use a "while loop" and "counter"</li>
</ol>

<p>We're getting there! We have a function to gather all of the search results on any given page. We now need a way to work systematically through all of the pages available. </p>

<p>To do that, we will add another loop to our "pull_records" function that allows us to move through more than one page of search results.</p>

<h3 id="introducing-the-while-loop">1. Introducing the While Loop</h3>

<p>The "for loop" allows us to do something to each item in a list. The "while loop" is a powerful tool that tells the computer to continue doing something as long as some criteria is true. We can use the "while loop" and a "counter" to work through all of the pages of search results.</p>

<p>To use a while loop, let's look again at our "pull records" function.</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre>def pull_records(pages, end, size):
	paged_search = dpla.search('cooking',fields=['sourceResource'], page_size=size, page=pages)
	# print paged_search.items[2]			
	save_each(paged_search)
</pre></td></tr></tbody></table>
</div>

<p>Remember, "pages" stands for the first page and "end" stands for the last page of search results we want. We want this function to run for every page of search results. In other words, if the page number is less than or equal to the total number of pages available, we want to get the search results from that page. Once we hit the end, we want to stop.</p>

<p>To write this logic into our existing function code, we will add:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>while(pages &lt;= end):
</pre></td></tr></tbody></table>
</div>

<p>so that our function now looks like this:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre>def pull_records(pages, end, size):
	while(pages &lt;= end):
		paged_search = dpla.search('cooking',fields=['sourceResource'], page_size=size, page=pages)
		# print paged_search.items[2]					
		save_each(paged_search)
</pre></td></tr></tbody></table>
</div>

<p>Can you see the problem with our current function? As it currently stands, "pages" is always less than "end" because it never increases. This means we would get stuck in an "infinite loop" if we tried to run the code right now – don't run the code at this point!</p>

<p>To avoid the "infinite loop", we need to increase the value of "pages" each time we work through the loop. We can do this by overwriting the value of "pages" to be "pages + 1".</p>

<p>Add "pages = pages +1" after <span class="command">save_each(paged_search)</span> like this:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre>def pull_records(pages, end, size):
		while(pages &lt;= end):
			paged_search = dpla.search('cooking',fields=['sourceResource'], page_size=size, page=pages)
			# print paged_search.items[2]					
			save_each(paged_search)
			pages = pages + 1
</pre></td></tr></tbody></table>
</div>

<p>Let's also add a print command to check that things are working as we expect. Above <span class="command">pages = pages + 1</span> add:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>print "finished page " + str(pages)
</pre></td></tr></tbody></table>
</div>

<p>Our file should now look like this:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></td><td class="code"><pre># Load Libraries
from dpla.api import DPLA

# Set Variables
dpla = DPLA('Your-Key-Here')
# result = dpla.search('cooking', fields=['sourceResource'], page_size = 50)
all_records = []

# Define Functions
def pull_records(pages, end, size):
	while(pages &lt;= end):
		paged_search = dpla.search('cooking',fields=['sourceResource'], page_size=size, page=pages)
		# print paged_search.items[2]
		save_each(paged_search)
		print "finished page " + str(pages)
		pages = pages + 1

def save_each(n):
	for each in n.items:
		all_records.append(each)

# Make Function Calls
# print result.items[1]
pull_records(2, 3, 50)
print all_records[30]
</pre></td></tr></tbody></table>
</div>

<p>Let's test our function on a subset of the pages. Change <span class="command">pull_records(2, 3, 50)</span> to <span class="command">pull_records(2, 5, 50)</span> and change <span class="command">print all_records[30]</span> to <span class="command">print all_records[150]</span></p>

<p>Save and run in Terminal.</p>

<h3 id="group-challenge">Group Challenge:</h3>

<p>Go back to your pen and paper and diagram a "while loop". </p>

<p><span class="left"><a href="module07.html">Previous Module</a></span>
<span class="right"><a href="module09.html">Next Module</a></span></p>

  <h3><a href="/modules/module13.html">Save Results to a File</a></h3>
  <!-- use article.summary(250) if you have Nokogiri available to show just
       the first 250 characters -->
  <p>We are almost there! We have been creating some interesting data on the word frequencies within the description fields. But so far, all of our results are stuck in Terminal, which makes it difficult for us to reuse them. So for this final module, we will write out the results of our count to a CSV (comma separated value) file.</p>

<h3 id="create-a-new-csv-file">Create a New CSV File</h3>

<p>As we did when we wrote our JSON results, we will start by telling Python to open a CSV file and assign to a variable.</p>

<p>Currently our script should look like this:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40</pre></td><td class="code"><pre># Import Libraries
import nltk
from nltk.corpus import stopwords
from nltk import word_tokenize
from nltk.probability import *

# Set Variables
with open('text_results.txt, 'r') as file:
    cooking_text = file.read().decode('utf8')

cooking_tokens = word_tokenize(cooking_text)
text = nltk.Text(cooking_tokens)

# Load in Stopwords Library
stopwords = stopwords.words('english')

word_set = []

# Define Functions
def normalize_text(text):
    # Work through all the words in text and filter
    for word in text:
        # Check if word is a word, and not punctuation, AND check against stop words
        if word.isalpha() and word.lower() not in stopwords:
            # If it passes the filters, save to word_set
            word_set.append(word.lower())
    return word_set

# Make Function Calls
#print cooking_text[0:20]
#print cooking_tokens[0:10]
#print text.concordance('economics')
#print text.collocations()
#print text.similar('Pot')

normalize_text(text)

fd = FreqDist(word_set)
print fd.most_common(200)
print fd.hapaxes()
</pre></td></tr></tbody></table>
</div>

<p>To create CSV files, we need to import the csv library, which is preinstalled, but not preloaded in Python. To do that, add <span class="command">import csv</span> to our list of libraries at the top of the file.</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre># Import Libraries
import nltk
from nltk.corpus import stopwords
from nltk import word_tokenize
from nltk.probability import *
import csv
</pre></td></tr></tbody></table>
</div>

<p>Now, we can create our CSV file right after the line where we opened the JSON file. CSV files open a little differently than text files, in that we open the file with a "writer" helper.</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre># Set Variables
with open('text_results.txt', 'r') as file:
    cooking_text = file.read().decode('utf8')

file = csv.writer(open('word_frequencies.csv', 'wb'))
</pre></td></tr></tbody></table>
</div>

<p>Now, at the end of our file, we can save the key(the word) and the count(the frequency) as two columns in our CSV file. If you did the graphing challenge, be sure to comment out <span class="command">fd.plot(50,cumulative=False)</span> as well. The plotting function and the write csv functions don't work well together.</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre>for key, count in fd.most_common(200):
    file.writerow([key, count])
</pre></td></tr></tbody></table>
</div>

<p>The final product should look like this:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47</pre></td><td class="code"><pre># Import Libraries
import nltk
from nltk.corpus import stopwords
from nltk import word_tokenize
from nltk.probability import *

# Set Variables
with open('text_results.txt, 'r') as file:
    cooking_text = file.read().decode('utf8')

file = csv.writer(open('word_frequencies.csv', 'w'))

cooking_tokens = word_tokenize(cooking_text)
text = nltk.Text(cooking_tokens)

# Load in Stopwords Library
stopwords = stopwords.words('english')

word_set = []

# Define Functions
def normalize_text(text):
    # Work through all the words in text and filter
    for word in text:
        # Check if word is a word, and not punctuation, AND check against stop words
        if word.isalpha() and word.lower() not in stopwords:
            # If it passes the filters, save to word_set
            word_set.append(word.lower())
    return word_set

# Make Function Calls
#print cooking_text[0:20]
#print cooking_tokens[0:10]
#print text.concordance('economics')
#print text.collocations()
#print text.similar('Pot')

normalize_text(text)

fd = FreqDist(word_set)
print fd.most_common(200)
#print fd.hapaxes()
#fd.plot(50,cumulative=False)

# Print results to a CSV file
for key, count in fd.most_common(200):
    file.writerow([key, count])
</pre></td></tr></tbody></table>
</div>

<p>You can open your CSV file using Terminal by typing or by looking within your "dhb_awesome" directory:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>open word_frequencies.csv
</pre></td></tr></tbody></table>
</div>

<p>The file will most likely open in Excel or a similar program. </p>

<p>Look over your results. What patterns strike you as interesting? As expected? As unexpected? What additional questions do these word frequencies raise? Now that you have this data, what additional information do you need to know to interpret the patterns we see here?</p>

<p><span class="left"><a href="module12.html">Previous Module</a></span></p>

  <h3><a href="/modules/module12.html">Analyzing a Subset of the Data (Part 2)</a></h3>
  <!-- use article.summary(250) if you have Nokogiri available to show just
       the first 250 characters -->
  <p>In this module we will learn to:</p>

<ol>
  <li>normalize our text</li>
  <li>use the Frequency Distribution library to find patterns in our text </li>
</ol>

<h3 id="normalizing-the-text">1. Normalizing the text</h3>

<p>While we can get a lot of information from the entirety of the text, we can also find additional patterns once we do what is called "normalizing" the text. This entails removing all of the punctuation marks and transforming all the words to lower case. It also involves removing the small connection words such as "the" and "a", which are very common in a text, but carry less semantic meaning than nouns, verbs, and adjectives.</p>

<p>To clean up the text, we need to work through each word and and run it through a series of checks or filters. </p>

<p>Open your "text_mining.py" file. First, comment out <span class="command">print text.similar('Pot')</span>. Next, let's create a new function that normalizes the text:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10</pre></td><td class="code"><pre># Define Functions
def normalize_text(text):
    # Work through all the words in text and filter

# Make Function Calls
#print cooking_text[0:20]
#print cooking_tokens[0:10]
#print text.concordance('economics')
#print text.collocations()
#print text.similar('Pot')
</pre></td></tr></tbody></table>
</div>

<p>To work through the words, we can use a new "for loop" and save all of the approved words into a new array named "word_set". Create your new array at the end of the "Set Variables" section.</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre>word_set = []

# Define Functions
def normalize_text(text):
    # Work through all the words in text and filter
    for word in text:
</pre></td></tr></tbody></table>
</div>

<p>First, for each word, let's check if it is alpha-numeric:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8</pre></td><td class="code"><pre>word_set = []

# Define Functions
def normalize_text(text):
    # Work through all the words in text and filter
    for word in text:
        # Check if word is a word, and not punctuation
        if word.isalpha()
</pre></td></tr></tbody></table>
</div>

<p>Next, let's check the word against the NLTK collection of stopwords. First, let's load in the NLTK stopwords and assign them to the variable "stopwords":</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16</pre></td><td class="code"><pre># Import Libraries
import nltk
from nltk.corpus import stopwords
from nltk import word_tokenize

# Set Variables
with open('text_results.txt', 'r') as file:
    cooking_text = file.read().decode('utf8')

cooking_tokens = word_tokenize(cooking_text)
text = nltk.Text(cooking_tokens)

# Load Stopwords
stopwords = stopwords.words('english')

word_set = []
</pre></td></tr></tbody></table>
</div>

<p>Next, we need to transform each word to lower-case, because the stopwords list won't catch the uppercase words. We do this by adding <span class="command">.lower()</span> to word as we check the words against the "stopwords" collection. </p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9</pre></td><td class="code"><pre>word_set = []

# Define Functions
def normalize_text(text):
    # Work through all the words in text and filter
    for word in text:
        # Check if word is a word, and not punctuation, AND check against stop words
        if word.isalpha() and word.lower() not in stopwords:
            # If it passes the filters, save to word_set
</pre></td></tr></tbody></table>
</div>

<p>Finally, we will add those words that pass through the filters to the "word_set" list and tell the function to return the whole list once it is finished.</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11</pre></td><td class="code"><pre>word_set = []

# Define Functions
def normalize_text(text):
    # Work through all the words in text and filter
    for word in text:
        # Check if word is a word, and not punctuation, AND check against stop words
        if word.isalpha() and word.lower() not in stopwords:
            # If it passes the filters, save to word_set
            word_set.append(word.lower())
    return word_set
</pre></td></tr></tbody></table>
</div>

<p>The last step is to call our "normalize_text" function and pass in our text.</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8</pre></td><td class="code"><pre># Make Function Calls
#print cooking_text[0:20]
#print cooking_tokens[0:10]
#print text.concordance('economy')
#print text.collocations()
#print text.similar('Pot')

normalize_text(text)
</pre></td></tr></tbody></table>
</div>

<p>Well done! We're now ready to calculate word frequencies using the Frequency Distribution library.</p>

<h3 id="get-word-frequencies">2. Get Word Frequencies</h3>

<p>Our Python file should now look like this: </p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35</pre></td><td class="code"><pre># Import Libraries
import nltk
from nltk.corpus import stopwords
from nltk import word_tokenize

# Set Variables
with open('text_results.txt', 'r') as file:
    cooking_text = file.read().decode('utf8')

cooking_tokens = word_tokenize(cooking_text)
text = nltk.Text(cooking_tokens)

# Load in Stopwords Library
stopwords = stopwords.words('english')

word_set = []

# Define Functions
def normalize_text(text):
    # Work through all the words in text and filter
    for word in text:
        # Check if word is a word, and not punctuation, AND check against stop words
        if word.isalpha() and word.lower() not in stopwords:
            # If it passes the filters, save to word_set
            word_set.append(word.lower())
    return word_set

# Make Function Calls
#print cooking_text[0:20]
#print cooking_tokens[0:10]
#print text.concordance('economy')
#print text.collocations()
#print text.similar('Pot')

normalize_text(text)
</pre></td></tr></tbody></table>
</div>

<p>We need one more library to get word frequencies from our array of approved words. After <span class="command">from nltk import word_tokenize</span>, add:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>from nltk.probability import *
</pre></td></tr></tbody></table>
</div>

<p>Now, we will use the Frequency Distribution function to get word counts. NLTK is a very powerful library, and by using it, we can draw on the work others to build and verify that the functions do what they say they do. There is no need to reinvent the wheel with every new script. Let's first use the library, and then work through what it did.</p>

<p>The first step is to run the Frequency Distribution function and save the results to a variable so they are easier to use. After <span>normalize_text(text)</span> add:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>fd = FreqDist(word_set)
</pre></td></tr></tbody></table>
</div>

<p>To see the 200 most common words, add to the bottom of the 'Make Function Calls' section:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>print fd.most_common(200)
</pre></td></tr></tbody></table>
</div>

<p>and run your script.</p>

<p>Frequency Distribution goes through the words in our list, checks if it has seen that word before, if yes, adds 1 to the count for that word, and if not, notes it as a new word with a count of 1. </p>

<p>Grab your drawing materials again, and draw a diagram of what the Frequency Distribution function is doing.</p>

<p>Your file should look like:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39</pre></td><td class="code"><pre># Import Libraries
import nltk
from nltk.corpus import stopwords
from nltk import word_tokenize
from nltk.probability import *

# Set Variables
with open('text_results.txt', 'r') as file:
    cooking_text = file.read().decode('utf8')

cooking_tokens = word_tokenize(cooking_text)
text = nltk.Text(cooking_tokens)

# Load in Stopwords Library
stopwords = stopwords.words('english')

word_set = []

# Define Functions
def normalize_text(text):
    # Work through all the words in text and filter
    for word in text:
        # Check if word is a word, and not punctuation, AND check against stop words
        if word.isalpha() and word.lower() not in stopwords:
            # If it passes the filters, save to word_set
            word_set.append(word.lower())
    return word_set

# Make Function Calls
#print cooking_text[0:20]
#print cooking_tokens[0:10]
#print text.concordance('economy')
#print text.collocations()
#print text.similar('Pot')

normalize_text(text)

fd = FreqDist(word_set) 
print fd.most_common(200)
</pre></td></tr></tbody></table>
</div>

<p>You can comment out print statements along the way if you are seeing too much information. </p>

<h3 id="bonus-challenge-for-the-ambitious">Bonus Challenge (for the ambitious)</h3>

<p>For some super magic, you can also generate a plot of the most frequent words. You will need to install <code>numpy</code> with <span class="command">sudo pip install -U numpy</span> and <code>matplotlib</code> with <span class="command">sudo pip install matplotlib</span>. </p>

<p>Add to your script:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>fd.plot(50,cumulative=False)
</pre></td></tr></tbody></table>
</div>

<p>and run.</p>

<p><span class="left"><a href="module11.html">Previous Module</a></span>
<span class="right"><a href="module13.html">Next Module</a></span></p>

  <h3><a href="/modules/module11.html">Analyzing the Data (Part 1)</a></h3>
  <!-- use article.summary(250) if you have Nokogiri available to show just
       the first 250 characters -->
  <p>Up to this point, we have been focusing on molding the data we got back from the DPLA into different formats. First, we chose the part of the data we wanted to save locally and looped through all of the search result "pages" to get our large dataset. Then, because our research question involved language use and text, we transformed the data again into a format that suits the kind of analysis we want to do. Now, we get to take the results of our hard work and start to interrogate our data.</p>

<p>In this module we will:</p>

<ol>
  <li>install NLTK library</li>
  <li>use NLTK to do see patterns in the text</li>
</ol>

<h3 id="installing-nltk">1. Installing NLTK</h3>

<p>We are interested in the language used in the three fields we singled out across all the "cooking" items in the DPLA database. Fortunately, there is good support within Python for text analysis and one powerful library we can use is the Natural Language ToolKit (or NLTK).</p>

<p>To install NLTK, let's go back to our Terminal and use <code>pip</code>.</p>

<p>Run <span class="command">pip install nltk</span>. You may need to use <span class="command">sudo pip install nltk</span>  (Mac).</p>

<p>There are also a number of datasets available for use with NLTK. For our purposes, we will only be using the "stopwords" dataset. You can browse the list of all the datasets you could download and use at <a href="http://www.nltk.org/nltk_data/">http://www.nltk.org/nltk_data/</a>. </p>

<p>To download the stopwords, we are going back into the Python Interactive Shell. Run <span class="command">python</span>. Your Terminal window should now look something like this:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre>Python 2.7.5 (default, Mar  9 2014, 22:15:05)
[GCC 4.2.1 Compatible Apple LLVM 5.0 (clang-500.0.68)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; 
</pre></td></tr></tbody></table>
</div>

<p>Type <span class="command">import nltk</span> and press Enter.</p>

<p>Next type <span class="command">nltk.download('stopwords')</span> and press Enter.</p>

<p>Once you see </p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre>True
&gt;&gt;&gt;
</pre></td></tr></tbody></table>
</div>

<p>you have successfully downloaded the stopwords file. </p>

<p>You will also need to download a tokenizing library. Still in the Python shell, run</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>nltk.download('punkt')
</pre></td></tr></tbody></table>
</div>

<p>Again, once you see</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre>True
&gt;&gt;&gt;
</pre></td></tr></tbody></table>
</div>

<p>the download is complete.</p>

<p>You can now exit the Python Interactive Shell using <span class="command">quit()</span></p>

<h3 id="lets-start-text-mining">Let's Start Text Mining</h3>

<p>Let's create a third script file, "text_mining.py":</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>touch text_mining.py
</pre></td></tr></tbody></table>
</div>

<p>(Windows):</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>New-Item -ItemType file text_mining.py
</pre></td></tr></tbody></table>
</div>

<p>And open that script file in your text editor:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>open text_mining.py
</pre></td></tr></tbody></table>
</div>

<p>(Windows):</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>Start notepad++ text_mining.py
</pre></td></tr></tbody></table>
</div>

<p>Let's start by importing the NLTK library and the stopwords:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre># Import Libraries
import nltk
from nltk.corpus import stopwords
</pre></td></tr></tbody></table>
</div>

<p>Next let's load in our text file:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre># Set Variables
with open('text_results.txt', 'r') as file:
    cooking_text = file.read().decode('utf8')
</pre></td></tr></tbody></table>
</div>

<p>Let's add a "print" command so we can display part of our text to make sure everything is loading correctly so far:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12</pre></td><td class="code"><pre># Import Libraries
import nltk
from nltk.corpus import stopwords

# Set Variables
with open('text_results.txt', 'r') as file:
    cooking_text = file.read().decode('utf8')

# Define Functions

# Make Function Calls
print cooking_text[0:20]
</pre></td></tr></tbody></table>
</div>

<p>Save and run this script in Terminal. Let's take a look at the results. One thing to note here is that Python treats the text as a list of letters. </p>

<p>For our purposes, we want to work with the words, so let's use a function called "tokenize" from the NLTK library. What "tokenize" does is teach Python that words exist. It goes through the text, looks for white space and punctuation, and then bundles the letters between the white space and punctuation together into "words". When we started, the computer considered our text to be a series of letters; after tokenizing, the computer sees the text as a list of "words". </p>

<p>After "from nltk.corpus import stopwords" in the variables section, add:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>from nltk import word_tokenize
</pre></td></tr></tbody></table>
</div>

<p>Now let's comment out the last print statement and transform our "words" into tokens using the "word_tokenize" function. To see what has happened, let's also print the first 10 tokens.</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16</pre></td><td class="code"><pre># Import Libraries
import nltk
from nltk.corpus import stopwords
from nltk import word_tokenize

# Set Variables
with open('text_results.txt', 'r') as file:
    cooking_text = file.read().decode('utf8')

cooking_tokens = word_tokenize(cooking_text)

# Define Functions

# Make Function Calls
#print cooking_text[0:20]
print cooking_tokens[0:10]
</pre></td></tr></tbody></table>
</div>

<p>Next, we need to do one more transformation on our words so that they will play nicely with NLTK. Comment out "print cooking_tokens[0:10]" and add to the variables section after <span class="command">cooking_tokens…</span>:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>text = nltk.Text(cooking_tokens)
</pre></td></tr></tbody></table>
</div>

<p>Your file should now look like this:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17</pre></td><td class="code"><pre># Import Libraries
import nltk
from nltk.corpus import stopwords
from nltk import word_tokenize

# Set Variables
with open('text_results.txt', 'r') as file:
    cooking_text = file.read().decode('utf8')

cooking_tokens = word_tokenize(cooking_text)
text = nltk.Text(cooking_tokens)

# Define Functions

# Make Function Calls
#print cooking_text[0:20]
#print cooking_tokens[0:10]
</pre></td></tr></tbody></table>
</div>

<p>The first thing we can do to get a sense of the words in our dataset is to use the "concordance" function within NLTK. This will print all the instances of a word with the surrounding words for context.</p>

<p>After <span class="command">#print cooking_tokens[0:10]</span>, add:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>print text.concordance('cooking')
</pre></td></tr></tbody></table>
</div>

<p>Save and run your script.</p>

<p>Pretty cool! Now change "cooking" to "economics", save and run the script, and see what the output is:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>print text.concordance('economics')
</pre></td></tr></tbody></table>
</div>

<p>Try some other words to get a sense of the word usage in the "text_results" file. You can either replace the word or add additional print statements.</p>

<p>Another useful command is "collocation". This shows us all the words that tend to appear together throughout the corpus.</p>

<p>Comment out <span class="command">print text.concordance('your_last_word')</span> and add </p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>print text.collocations()
</pre></td></tr></tbody></table>
</div>

<p>Save and run your script.</p>

<p>One more function that is useful for surveying our data is "similar". This shows us words that are used similarly to the word we give it.</p>

<p>Comment out <span class="command"> print text.collocations()</span> and add:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>print text.similar('Pot')
</pre></td></tr></tbody></table>
</div>

<p>Your script should now look like:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21</pre></td><td class="code"><pre># Import Libraries
import nltk
from nltk.corpus import stopwords
from nltk import word_tokenize

# Set Variables
with open('text_results.txt', 'r') as file:
    cooking_text = file.read().decode('utf8')

cooking_tokens = word_tokenize(cooking_text)
text = nltk.Text(cooking_tokens)

# Define Functions

# Make Function Calls
#print cooking_text[0:20]
#print cooking_tokens[0:10]
#print text.concordance('economics')
#print text.collocations()

print text.similar('Pot')
</pre></td></tr></tbody></table>
</div>

<p>What other patterns might be interesting to know about the words used to describe objects related to "cooking"?</p>

<p>In the next module, we will look at word counts to find the most common words used across all of the different DPLA contributors. </p>

<p><span class="left"><a href="module10.html">Previous Module</a></span>
<span class="right"><a href="module12.html">Next Module</a></span></p>

  <h3><a href="/modules/module10.html">Working with Local Data</a></h3>
  <!-- use article.summary(250) if you have Nokogiri available to show just
       the first 250 characters -->
  <p>In this module we will learn:</p>

<ol>
  <li>to create a new script file and load in our JSON data</li>
  <li>to select data from particular fields and deal with missing data</li>
  <li>to convert our JSON data to strings of text</li>
</ol>

<p>Now that we have a very large file of JSON data, we can work locally to find patterns that we could not find using the online interface for the DPLA's holdings. Since we are interested in the language being used in order to investigate how the descriptions of "cooking" items are gendered, our next step is to clean up that data and save it as text only so we can do different analyses on it in later modules.</p>

<h3 id="create-a-new-script-and-load-in-our-data">1. Create a New Script and Load in Our Data</h3>

<p>It is time to create a new script file!</p>

<p>Go to Terminal and type:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>touch my_second_script.py 
</pre></td></tr></tbody></table>
</div>

<p>or on Windows: </p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>New-Item -ItemType file my_second_script.py
</pre></td></tr></tbody></table>
</div>

<p>To open your new script file, type:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>open my_second_script.py
</pre></td></tr></tbody></table>
</div>

<p>or on Windows:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>Start notepad++ my_second_script.py
</pre></td></tr></tbody></table>
</div>

<p>First, we will need the JSON library again. To add this, add <span class="command">import json</span> to the very top of the file.</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre># Load Libraries
import json
</pre></td></tr></tbody></table>
</div>

<p>The next thing is to load up the data from our "search_results.json" file.</p>

<p>The structure for this is:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre># Set Variables
with open("search_results.json") as json_file:
    json_data = json.load(json_file)
</pre></td></tr></tbody></table>
</div>

<p>Here, we tell Python to open our "search_results.json" file and assign it to the variable "json_file". Then we use the "load" method from the JSON library to load up the data and save it as the variable "json_data". </p>

<p>Our second script file should now look like:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10</pre></td><td class="code"><pre># Load Libraries
import json

# Set Variables
with open("search_results.json") as json_file:
    json_data = json.load(json_file) 

# Define Functions

# Make Function Calls  
</pre></td></tr></tbody></table>
</div>

<p>To make sure this worked, let's print out one item from the JSON data. Work with your table to add a "print" statement that prints the second item in the "json_data" list.</p>

<h3 id="select-the-relevant-text-data">2. Select the Relevant Text Data</h3>

<p>Our research question for this data is how, across the entire DPLA collection, the descriptions of items related to cooking are gendered. To pursue this question, we need to do some basic text analysis, so let's save our search results in a format that makes it easy to do that.</p>

<p>The next step is to select the fields that will be most helpful for analyzing how "cooking" items are described across the items in the DPLA.</p>

<p>Looking at our items, there are three main fields containing description-type information for our different "cooking" items: the title, the description, and the subject headings. </p>

<p>To start, let's make a new function called "get_text" that takes in our "json_data" list:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre># Define Functions
def get_text(json_data):
    # Do something to each item in json_data
</pre></td></tr></tbody></table>
</div>

<p>Next, for each item in that array, we want to look for the "title", the "description", and the "subject heading fields". This means using another "for loop". </p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre># Define Functions    
def get_text(json_data):
    for each in json_data:
        # Get the titles
        # Get the descriptions
        # Get the subject headings
</pre></td></tr></tbody></table>
</div>

<p>We can get the title, description, and subject headings by looking for those "keys" within each item in our "json_data" list. </p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11</pre></td><td class="code"><pre># Define Functions    
def get_text(json_data):
    for each in json_data:
        # Get the title
        find_titles = each['sourceResource']['title']

        # Get the Description
        find_descriptions = each['sourceResource']['description']

        # Get the Subject Headings
        find_subjects = each['sourceResource']['subject']
</pre></td></tr></tbody></table>
</div>

<p>So far so good. But what if one of these fields is missing? Programming languages are very literal: if you tell it to do something that it cannot do, it just stops and gives you an error. To see this in action, let's add a line in "Make Function Calls" to call the function.</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></td><td class="code"><pre># Load Libraries
import json

# Set Variables
with open('search_results.json') as json_file:
    json_data = json.load(json_file) 

# Define Functions
def get_text(json_data):
    for each in json_data:
        # Get the Titles
        find_titles = each['sourceResource']['title']

        # Get the Descriptions
        find_descriptions = each['sourceResource']['description']

        # Get the Subject Headings
        find_subjects = each['sourceResource']['subject']

# Make Function Calls
print json_data[1]
get_text(json_data)
</pre></td></tr></tbody></table>
</div>

<p>Towards the end of the error message, you should see a line that says "KeyError: 'sourceResource.description'". This is Python telling you that it cannot find a key "title" in one of the resources.</p>

<p>To deal with this, we use "try" and "except" – we will tell the computer to try to find the keys, but if it doesn't, to assign the value to an empty space and move on.</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20</pre></td><td class="code"><pre># Define Functions
def get_text(json_data):
    for each in json_data:
        # Get the Titles
        try:
            find_titles = each['sourceResource']['title']
        except:
            title = ' '
        
        # Get the Descriptions
        try:
            find_descriptions = each['sourceResource']['description']
        except:
            description = ' '

        # Get the Subject Headings
        try:
            find_subjects = each['sourceResource']['subject']
        except:
            subject = ' '
</pre></td></tr></tbody></table>
</div>

<p>There are two more steps we need to get the text ready to save. The first step is to get all of the data out of lists and make sure that it is in the form of a string.</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39</pre></td><td class="code"><pre># Define Functions
def get_text(json_data):
    for each in json_data:
        # Get the Titles
        try:
            find_titles = each['sourceResource']['title']
            if isinstance(find_titles, basestring):
                title = find_titles.encode('utf8')
            else:
                for each in find_titles:
                    title = each.encode('utf8')
        except:
            title = ' '
        
        # Get the Descriptions
        try:
            find_descriptions = each['sourceResource']['description']
            if isinstance(find_descriptions, basestring):
                description = find_descriptions.encode('utf8')
            else:
                for each in find_descriptions:
                    description = each.encode('utf8')
        except:
            description = ' '

        # Get the Subject Headings
        try:
            find_subjects = each['sourceResource']['subject']
            if isinstance(find_subjects, basestring):
                subject = find_subjects.encode('utf8')
            else:
                subject_list = []
                for each in find_subjects:
                    subject_list.append(each['name'])  

                combined_subjects = ', '.join(subject_list)
                subject = combined_subjects.encode('utf8')
        except:
            subject = ' '
</pre></td></tr></tbody></table>
</div>

<p>You might notice two different things with this function. First, we are reusing variable names. Variables hold the last thing passed to them, so we can overwrite the value of a variable to update it as we go along. </p>

<p>Second, we are handling the subject field differently than the title and description fields. This is because the subject key holds an additional list, rather than just values. </p>

<p>Work with your group to map out what is going on in the subject section of the function.</p>

<p>The last is to save this data into a text file. Similar to last time, we need to set up the file that will receive that data:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8</pre></td><td class="code"><pre># Load Libraries
import json

# Set Variables
with open("search_results.json") as json_file:
    json_data = json.load(json_file) 

f = open('text_results.txt', 'w')
</pre></td></tr></tbody></table>
</div>

<p>The major difference here is that we are opening the file as append so that we can save each line of data as we loop, rather than storing it all and writing it all at once.</p>

<p>Now, let's go back to the function and put all our pieces together into a new variable.</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42</pre></td><td class="code"><pre># Define Functions
def get_text(json_data):
    for each in json_data:
        # Get the Titles
        try:
            find_titles = each['sourceResource']['title']
            if isinstance(find_titles, basestring):
                title = find_titles.encode('utf8')
            else:
                for each in find_titles:
                    title = each.encode('utf8')
        except:
            title = ' '
        
        # Get the Descriptions
        try:
            find_descriptions = each['sourceResource']['description']
            if isinstance(find_descriptions, basestring):
                description = find_descriptions.encode('utf8')
            else:
                for each in find_descriptions:
                    description = each.encode('utf8')
        except:
            description = ' '

        # Get the Subject Headings
        try:
            find_subjects = each['sourceResource']['subject']
            if isinstance(find_subjects, basestring):
                subject = find_subjects.encode('utf8')
            else:
                subject_list = []
                for each in find_subjects:
                    subject_list.append(each['name'])  

                combined_subjects = ', '.join(subject_list)
                subject = combined_subjects.encode('utf8')
        except:
            subject = ' '

        # Combine the data into a single variable in the form of a sentence
        data = title + '; ' + description + '; ' + subject + '. \n'
</pre></td></tr></tbody></table>
</div>

<p>This line takes the information held in the title field, adds a ";" and a space, takes the information in the description field, add '; and a space, and finally, takes the list held in the subject field and smashes it together into a string, separated by a comma and a space. Finally, the "\n" adds an "Enter" to the end of the line, so that the information for each item appears on a new line.</p>

<p>The last step is to write all the information within "data" to our file directly under the line just added:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre>        # Combine the data into a single variable in the form of a sentence
        data = title + '; ' + description + '; ' + subject + '. \n'

        # Write the sentence to the 'text_results' file
        f.write(data)
</pre></td></tr></tbody></table>
</div>

<p>Last, let's add a call to the function:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57</pre></td><td class="code"><pre># Load Libraries
import json

# Set Variables
with open("search_results.json") as json_file:
    json_data = json.load(json_file)

f = open('text_results.txt', 'w')

# Define Functions
def get_text(json_data):
    for each in json_data:
        # Get the Titles
        try:
            find_titles = each['sourceResource']['title']
            if isinstance(find_titles, basestring):
                title = find_titles.encode('utf8')
            else:
                for each in find_titles:
                    title = each.encode('utf8')
        except:
            title = ' '
        
        # Get the Descriptions
        try:
            find_descriptions = each['sourceResource']['description']
            if isinstance(find_descriptions, basestring):
                description = find_descriptions.encode('utf8')
            else:
                for each in find_descriptions:
                    description = each.encode('utf8')
        except:
            description = ' '

        # Get the Subject Headings
        try:
            find_subjects = each['sourceResource']['subject']
            if isinstance(find_subjects, basestring):
                subject = find_subjects.encode('utf8')
            else:
                subject_list = []
                for each in find_subjects:
                    subject_list.append(each['name'])  

                combined_subjects = ', '.join(subject_list)
                subject = combined_subjects.encode('utf8')
        except:
            subject = ' '

        # Combine the data into a single variable in the form of a sentence
        data = title + '; ' + description + '; ' + subject + '. \n'

        # Write the sentence to the 'text_results' file
        f.write(data)

# Make Function Calls
get_text(json_data)
</pre></td></tr></tbody></table>
</div>

<p>Save and run your second Python script. You should now have a file named "text_results.txt" in your "dhb_awesome" directory. If you open that file, you should see lines of beautiful text ready for analysis.</p>

<p>In the next module, we will use the Natural Language ToolKit, a powerful Python library for working with text, to find patterns in the text data.</p>

<p><span class="left"><a href="module09.html">Previous Module</a></span>
<span class="right"><a href="module11.html">Next Module</a></span></p>

  <h3><a href="/modules/module09.html">Writings Search Results to a File</a></h3>
  <!-- use article.summary(250) if you have Nokogiri available to show just
       the first 250 characters -->
  <p>In this module we will learn:</p>

<ol>
  <li>how to save our results to a file</li>
</ol>

<p>In this module, we will focus on writing the results of our functions to a text file. This gives us a local copy of the data so that we only hit the DPLA servers once for the entire collection of files.</p>

<h3 id="saving-our-search-results">Saving our Search Results</h3>

<p>In order to save our search results, we first need to add a line to our code that creates the file we will save to. In your "my_first_script.py" file, right under the "all_records" variable in the "Define Variables" section, add:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>f = open('search_results.json', 'w')
</pre></td></tr></tbody></table>
</div>

<p>Your file should now look like this:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></td><td class="code"><pre># Load Libraries
from dpla.api import DPLA

# Set Variables
dpla = DPLA('Your-Key-Here')
# result = dpla.search('cooking', fields=['sourceResource'], page_size = 50)
all_records = []

f = open('search_results.json', 'w')

# Define Functions
def pull_records(pages, end, size):
	while(pages &lt;= end):
		paged_search = dpla.search('cooking',fields=['sourceResource'], page_size=size, page=pages)
		# print paged_search.items[2]
		save_each(paged_search)
		print 'finished page ' + str(pages)
		pages = pages + 1

def save_each(n):
	for each in n.items:
		all_records.append(each)

# Make Function Calls
# print result.items[1]
pull_records(2, 5, 50)
print all_records[150]	
</pre></td></tr></tbody></table>
</div>

<p>Here you are combining a function - open("search_results.json") - with the declaration of a variable. The "open" function both opens an existing file and creates a file if the file does not already exist on your computer. The "w" indicates that the file should be opened as "write". One thing to note about "w" - "write" gives the computer permission to overwrite the data inside the file, which is why we are opening the file once and writing the whole array at the end. If we were to write each item as we looped, we would end up with only the last item in the file. It would write and overwrite each item as it went along. If you need to write inside a loop, you can open the file as "a" instead. This tells the computer to "append" the information to the end of the file, rather than overwrite the existing information. </p>

<p>Python has libraries for working with JSON, but because these are more specialized libraries, they are not automatically loaded into Python. Since we will be writing a JSON object, let's load that library into our file with <span class="command">import json</span>:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre># Load Libraries
from dpla.api import DPLA
import json
</pre></td></tr></tbody></table>
</div>

<p>Now that we have a file to write to, let's create a third function named "save_results" to write our search results to the file. Place this function after the "save_each" function.</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre>def save_results():
	data = json.dumps(all_records)
	f.write(data)
	f.close
</pre></td></tr></tbody></table>
</div>

<p>Let's look at how this function works: first, it creates a variable called "data" which we made using "json.dumps", another function now available to us because we loaded the "json" library. Next, it takes the file variable from the first part of the module and writes all of the information contained in "data" to it. Then it closes the file.</p>

<h3 id="calling-the-write-function">Calling the "Write" Function</h3>

<p>To run the "save_results" function, call the function at the end of the file with: </p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>save_results()
</pre></td></tr></tbody></table>
</div>

<p>Our file should now look like this:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33</pre></td><td class="code"><pre># Load Libraries
from dpla.api import DPLA
import json

# Set Variables
dpla = DPLA('Your-Key-Here')
# result = dpla.search('cooking', fields=['sourceResource'], page_size = 50)
all_records = []
f = open('search_results.json', 'w')

# Define Functions
def pull_records(pages, end, size):
	while(pages &lt;= end):
		paged_search = dpla.search('cooking',fields=['sourceResource'], page_size=size, page=pages)
		# print paged_search.items[2]
		save_each(paged_search)
		print 'finished page ' + str(pages)
		pages = pages + 1

def save_each(n):
	for each in n.items:
		all_records.append(each)

def save_results():
	data = json.dumps(all_records)
	f.write(data)
	f.close

# Make Function Calls
# print result.items[1]
pull_records(2, 5, 50)
print all_records[150]
save_results()
</pre></td></tr></tbody></table>
</div>

<p>Test that everything is working by running your "my_first_script.py" in Terminal.</p>

<p>Open your new "search_results.json" file and check that 200 items made it in. Close the file once you're done.</p>

<p>Congratulations! You've written your first results file!</p>

<h3 id="saving-all-the-search-results">Saving all the Search Results</h3>

<p>Finally, let's change the parameters we pass to the "pull_records" function to get all of the search results.</p>

<p>Remember, the first number we pass to "pull_records" corresponds to the first page of search results, the second number to the last page of search results, and the third number is the number of items per page. The DPLA will cap us at 500 items per page, so let's take "500" for our third variable. We also want to start with the first page, so "1" is our first variable.</p>

<p>To figure out the value we want for "end", we need to do a little math. If we have 10,909 items and can get 500 items a page, how many pages do we have to work through?</p>

<p>Update your "pull_records" line to:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>pull_records(1, 22, 500)
</pre></td></tr></tbody></table>
</div>

<p>Save and run your script. </p>

<p>Well done! You now have a local copy of all the data that we want to analyze! You have done a lot of work! Take a moment, refresh your brain with some coffee and sugar, and come back for the last leg of the tutorial!</p>

<p><span class="left"><a href="module09.html">Previous Module</a></span>
<span class="right"><a href="module10.html">Next Module</a></span></p>

  <h3><a href="/modules/module14.html">Oh, the Places You'll Go!</a></h3>
  <!-- use article.summary(250) if you have Nokogiri available to show just
       the first 250 characters -->
  <p>Congratulations! You have completed the tutorial!</p>

<p>Your brain should feel exhausted and you might feel a bit disoriented. This is normal! We have introduced many new concepts and ways of thinking today, and it will take some time for it all to sink in.</p>

<p>Bringing together humanities thinking and computational thinking is no easy challenge, but it can help generate some really interesting lines of inquiry. Once we think it terms of cycling through a dataset, we can start to form questions about patterns within a large set of examples, and even questions about models and systems. However, it is important to emphasize that these questions augment, rather than replace, more standard lines of humanities inquiry. Transforming our subject matter into data and processing it algorithmically is one 'reading' among many, one way of isolating those aspects of the material that we think are crucial for understanding the whole.</p>

<p>This tutorial is only a starting point, and there are many resources out there for you to continue learning in the list below. These tutorials will help flesh out the concepts we touched on here, such as variables, functions, and loops, as well as introduce new and more complex concepts. What is most helpful, and what will help keep you motivated along the way, is keeping in mind big humanities questions that require thinking computationally about your material, questions that require you to create data from your materials and then use that data to find patterns and connections. </p>

<h2 id="continue-learning">Continue Learning</h2>

<h3 id="online-tutorials">Online Tutorials</h3>

<ul>
  <li>
    <p>If you are interested in NLTK and want to learn some programming at the same time, the NLTK book offers an introduction to programming, Python, and language processing: <a href="http://www.nltk.org/book/">Natural Language Processing with Python</a></p>
  </li>
  <li>
    <p>If you want to dive into programming and Python at a more abstract level, <strong>Learn Python the Hard Way</strong> is a useful resource: <a href="http://learnpythonthehardway.org/book/">Learn Python the Hard Way</a></p>
  </li>
  <li>
    <p>If you are interested in tutorials for specific, humanities related, tasks, <strong>The Programming Historian</strong> is an excellent resource. It also offers an introductory series of tutorials for programming with Python: <a href="http://programminghistorian.org/lessons/">The Programming Historian</a></p>
  </li>
</ul>

<h3 id="workshops">Workshops</h3>

<ul>
  <li><a href="http://dhsi.org/">The Digital Humanities Summer Institute</a> offers courses on code, as well as on using software to work computationally with humanities data.</li>
</ul>


  <h3><a href="/modules/module07.html">Functions and Loops</a></h3>
  <!-- use article.summary(250) if you have Nokogiri available to show just
       the first 250 characters -->
  <p>In this module, we will learn</p>

<ol>
  <li>To create and call functions</li>
  <li>To create a "for loop"</li>
  <li>To "append" or add items to a list</li>
</ol>

<p>We are now ready to start writing a function to gather all of the information we want from the DPLA.</p>

<p>We now have a file that looks like this:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12</pre></td><td class="code"><pre># Load Libraries
from dpla.api import DPLA

# Set Variables
dpla = DPLA('Your-Key-Here')
# result = dpla.search('cooking', fields=['sourceResource'], page_size = 50)
all_records = []

# Define Functions

# Make Function Calls
# print result.items[1]
</pre></td></tr></tbody></table>
</div>

<p>We will now add a function that handles the query for any given page number.</p>

<h3 id="creating-a-pull-records-function">1. Creating a "Pull Records" Function</h3>

<p>Functions are little packets of code that do particular tasks. They involve variables and processes, they take what is given to them, and spit out a result. </p>

<p>To write a function, we start with the word "def", then give our function a name, and finally end with '():' Inside the parentheses, we can indicate how many pieces of information are going into the function.</p>

<p>In your "my_first_script.py" file, add the line</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre># Define Functions
def pull_records(pages, end, size):
</pre></td></tr></tbody></table>
</div>

<p>In this line, you have declared a 'pull_records' function, and told the computer that this function will involve three variables (pages, end, and size).These three variables are arbitrary (you could name them "snap", "crackle", and "pop") but will stand for the first page, the last page, and the number of items per page. </p>

<p>We are now ready to add the steps involved in getting the search records. </p>

<p>On the next line, tab in once and type:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre># Define Functions
def pull_records(pages, end, size):
	paged_search = dpla.search('cooking', fields=['sourceResource'], page_size=size, page=pages)
</pre></td></tr></tbody></table>
</div>

<p>Your file should now look like this:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14</pre></td><td class="code"><pre># Load Libraries
from dpla.api import DPLA

# Set Variables
dpla = DPLA('Your-Key-Here')
# result = dpla.search('cooking', fields=['sourceResource'], page_size = 50)
all_records = []

# Define Functions
def pull_records(pages, end, size):
	paged_search = dpla.search('cooking', fields=['sourceResource'], page_size=size, page=pages)

# Make Function Calls
# print result.items[1]
</pre></td></tr></tbody></table>
</div>

<p>It is important to note that Python is white-space aware: when writing functions in Python, white space is used to designate what is in a function or within a loop and what is outside of it.</p>

<p>Let's add a "print" statement to our function and test out the first stage of this function. On the next line, tab in and add the following "print" statement after "paged_search…":</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre># Define Functions
def pull_records(pages, end, size):
	paged_search = dpla.search('cooking', fields=['sourceResource'], page_size = size, page = pages)
	print paged_search.items[2]
</pre></td></tr></tbody></table>
</div>

<p>Now to run the function, we will call the function name and give it values. On a new line in the 'Make Function Calls' section, add the line:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre># Make Function Calls
# print result.items[1]
pull_records(2, 3, 50)
</pre></td></tr></tbody></table>
</div>

<p>Your file should now look like:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16</pre></td><td class="code"><pre># Load Libraries
from dpla.api import DPLA

# Set Variables
dpla = DPLA('Your-Key-Here')
# result = dpla.search('cooking', fields=['sourceResource'], page_size = 50)
all_records = []

# Define Functions
def pull_records(pages, end, size):
	paged_search = dpla.search('cooking', fields=['sourceResource'], page_size = size, page = pages)
	print paged_search.items[2]

# Make Function Calls
# print result.items[1]
pull_records(2, 3, 50)
</pre></td></tr></tbody></table>
</div>

<p>Save the file and go to Terminal to run it. Then come back to the function and work with your table to understand how the function worked.</p>

<h3 id="using-a-for-loop-to-save-items-to-allrecords">2. Using a 'for loop' to save items to 'all_records'</h3>

<p>You have written and executed your first function! Well done!</p>

<p>Now we need to add another function to store those results to the empty 'all_records' array we set up in the last module. While this is not necessary when you only have one page of results, it becomes necessary when you are trying to save from multiple pages.</p>

<p>To set up our new "Save Each" function, we will define a new function in our my_first_script.py file. Good practice is to group our functions together toward the top of the file, so put the "save_each" function after "pull_records" but before we call the "pull_records" function:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>def save_each(n):
</pre></td></tr></tbody></table>
</div>

<p>The 'n' here is again arbitrary. We are telling the function that there is one variable that we will be passing in, and to take that variable and plug it in for 'n' throughout the function.</p>

<p>We now need to add our first loop. With our current search, there are 50 items in our paged_search variable. We want to save each of those items separately to the "all_records" list. This means the computer needs to move through each individual item, grab the item, and add it to "all_records". </p>

<p>Tabbing in one space on the next line under <span class="command">def save_each(n):</span>s add:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre>def save_each(n):
	for each in n.items:
		# do something to every item in the list of items
</pre></td></tr></tbody></table>
</div>

<p>This is called a "for loop". It tells the computer to iterate through each item in the list "n". </p>

<p>Because this is a process inside a process, we need to tab in again. Each time we have a new loop or new function, we tab in all the lines associated with that process. To show that we're done listing steps for a particular process, we tab back out.</p>

<p>To add the item to the "all_records" array, we use the "append" command:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre>def save_each(n):
	for each in n.items:
		# do something to every item in the list of items
		all_records.append(each)
</pre></td></tr></tbody></table>
</div>

<p>"Append" grabs the value of "each" and adds it to the series we are saving as a list.</p>

<p>Now we can use this function in our "pull records" function. Currently, our "pull records" function looks as follows:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre>def pull_records (pages, end, size):
	paged_search = dpla.search('cooking', fields=['sourceResource'],  page_size=size, page=pages)
	print paged_search.items[2]
</pre></td></tr></tbody></table>
</div>

<p>Let's comment out the "print paged_search.item[2]" line, because that was just there to check that the first bit worked. </p>

<p>Now add a call to the "save_each" function, that passes in our search results. </p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre>def pull_records (pages, end, size):
	paged_search = dpla.search('cooking', fields=['sourceResource'],  page_size=size, page=pages)
	# print paged_search.items[2]	
	save_each(paged_search)
</pre></td></tr></tbody></table>
</div>

<p>Our file should now look like:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></td><td class="code"><pre># Load Libraries
from dpla.api import DPLA

# Set Variables
dpla = DPLA('Your-Key-Here')
# result = dpla.search('cooking', fields=['sourceResource'], page_size = 50)
all_records = []

# Define Functions
def pull_records (pages, end, size):
	paged_search = dpla.search('cooking', fields=['sourceResource'],  page_size=size, page=pages)
	# print paged_search.items[2]	
	save_each(paged_search)

def save_each(n):
	for each in n.items:
		# do something to every item in the list of items
		all_records.append(each)

# Make Function Calls
# print result.items[1]
pull_records(2, 3, 50)
</pre></td></tr></tbody></table>
</div>

<p>To test this, let's now add a "print" statement to the end of the file, after the "pull_records" function has been run, to make sure that the items are going into the "all_records" variable.</p>

<p>After "pull_records()" add:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>print all_records[30]
</pre></td></tr></tbody></table>
</div>

<p>Save and run your script.</p>

<p>We have made great progress! We now have two functions to handle making the query and saving the results, but we are still only working with one "page" of search results at a time. In the next module, we will add yet another kind of loop in order to move through the different pages.</p>

<h3 id="group-challenge">Group Challenge</h3>

<p>Break out the paper and pencils. Work as a group to create a diagram or metaphor for a "for loop". When would a "for loop" be useful?  </p>

<p><span class="left"><a href="module06.html">Previous Module</a></span>
<span class="right"><a href="module08.html">Next Module</a></span></p>

  <h3><a href="/modules/module06.html">Moving to Phase Two</a></h3>
  <!-- use article.summary(250) if you have Nokogiri available to show just
       the first 250 characters -->
  <p>In this module we will learn:</p>

<ol>
  <li>To add additional parameters to our API call</li>
  <li>To create an empty list</li>
  <li>To comment-out code that we don't want to run, but want to keep</li>
</ol>

<p>It is time stop briefly and think through what we have already learned. So far, we have learned to interact with your computer using the terminal, and with Python (a programming language) we used to execute a simple program. We have also learned how to use <code>pip</code> to add additional libraries to Python, and thought about how we can combine libraries to create new programs.</p>

<p>We also learned about data and APIs. We looked at JSON as a way of structuring data and thought about what it means to represent things in this format. Then, we looked at the DPLA API and learned how to leverage libraries like DPyLA to use the API in our code. Finally, we saved our code in a Python file that we learned how to execute in the terminal.</p>

<p>Well Done!</p>

<p>So far you have been writing code that does one thing: it get search results or prints a particular item. The power of computation, however, is being able to do the same thing to a series of items. This means thinking in terms of iterating through a series of items, doing the same thing to each in order to work to an answer. To do this, we will learn two very powerful programming concepts: functions and loops.</p>

<h3 id="anatomy-of-a-python-script-file">Anatomy of a Python Script File</h3>

<p>Just like when we are writing papers or structuring an argument, order matters in our script files. The computer will execute the code in the order it encounters it.</p>

<p>One good way to keep your code organized and avoid bugs caused by organization errors is to follow a set pattern when constructing your scripts.</p>

<p>First, at the top of your files, place the list of libraries you're importing. This way they are ready for use throughout the script. We did this when we started with <span class="command">from dpla.api import DPLA</span>.</p>

<p>Next, declare (or set) the variables (names) that you will use through the script. In code-speak, these are set at the "global scope" meaning that they are available to all functions in the file. We did this when we assigned our API key to the "<code>dpla</code>" variable with <span class="command">dpla = DPLA("YourAPIKey")</span> and when we saved our search to "<code>results</code>" with <span class="command">result = dpla.search("cooking")</span>.</p>

<p>After the variables, we will put our functions. Functions are like mini-scripts or packets of code that do one job. We can then combine functions to create more complicated programs. We will add some functions to our script in the next modules.</p>

<p>Finally, at the send of the file, we put the "calls to the functions" or commands to execute functions. To do this, we use the function name and (usually) parens "<code>()</code>". One exception is the "<code>print</code>" function, which doesn't require parens in the version of Python we are using for this workshop. We called the "<code>print</code>" function to print one item from our search results. It is important to call the functions in the order that you want them to be run.</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16</pre></td><td class="code"><pre># Load Libraries
import [library name]

# Set Variables
my_string = "information to be stored in my_var"

# Define Functions
def my_function(my_string):
	#do something to "my_string"
	my_list = str.split(my_string)
	return my_list

# Make Function Calls
my_var = my_function()

print my_var[1]
</pre></td></tr></tbody></table>
</div>

<h3 id="asking-questions-of-our-data">Asking Questions of Our Data</h3>

<p>We have been able to do a lot with filtering the data. But what if we want to ask questions about how the objects associated with "cooking" are described across all 10,000+ items? Say we are interested in how those descriptions of items related to cooking are gendered. How would we investigate patterns across the entirety of the DPLA's holdings related to "cooking" and gender?</p>

<p>There are many ways one could go about investigating the descriptions. Work with your table to brainstorm a couple of approaches.</p>

<h3 id="adding-parameters-to-the-query">1. Adding Parameters to the Query</h3>

<p>The first step is to get all of the relevant data. To do that, we need to restructure our query so we can control the number of items and the which "page" of results we retrieve. Remember that the API by default gives us 10 items at a time. We can add a parameter to our query to get up to 500 items at a time, but there were nearly 11,000 items associated with "cooking". This means we need to retrieve all 23 pages of 500 items.</p>

<p>Open your "my_first_script.py" file. Look at the line that says:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>result = dpla.search('cooking')
</pre></td></tr></tbody></table>
</div>

<p>First, let's narrow down the information we get back for each item from the DPLA. Looking at the documentation, we can do this by identifying the field names we are interested in. Looking at the search results, the description information, the titles, and subject headings are all found under 'sourceResource'. We can limit our results by adding <span class="command">fields=['sourceResource']</span> to our search:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>result = dpla.search('cooking', fields=['sourceResource'])
</pre></td></tr></tbody></table>
</div>

<p>This gives us a smaller set of data that is applicable to our questions, but with enough context in case we need to work back to the original item.</p>

<p>Next, let's change the number of items we get back by adding an additional parameter to what we pass to "<code>dpla.search</code>". Looking at the documentation, we learn that the syntax for setting the number of items is <span class="command">page_size=</span> and the number of items we want. To get 50 items rather than 10, change that line to:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>result = dpla.search('cooking', fields=['sourceResource'], page_size = 50)
</pre></td></tr></tbody></table>
</div>

<p>To check that this worked, let's add a line telling the computer to print out the 40th item:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>print result.items[39]
</pre></td></tr></tbody></table>
</div>

<p>Remember, counting within a list begins at 0.</p>

<h3 id="group-challenge">Group Challenge</h3>

<p>Using the <a href="https://github.com/bibliotechy/DPyLA">documentation</a>, work with your group to add another parameter to get the information from page 3 of the search results.</p>

<h3 id="creating-a-variable">2. Creating a Variable</h3>

<p>To get all 10,000+ items associated with cooking, we need to do two things: we need to get the items from all of the pages and we need a place to store them, so that as we get new items, our collection grows.</p>

<p>Let's tackle the second problem first. Remember back when we discussed variables? Variables are names we use to hold values. We can also use variables to hold lists. A list holds a series of items, such as <span class="command">fruit = ['apple', 'orange', 'banana']</span></p>

<p>We are going to use a similar structure to save all of the items we get back from the DPLA.</p>

<h3 id="commenting-out-code">3. Commenting Out Code</h3>

<p>Go back to "<code>my_first_script.py</code>" in your editor. "Comment out" the line <span class="command">result = dpla.search('cooking', fields=['sourceResource'], page_size=50)</span> by putting a <code>#</code> at the beginning of the line. When your computer executes the file, it will skip all lines that start with a pound sign. This allows you to leave comments for yourself or to test new ways of doing things without loosing your work and tells the computer to skip this line.</p>

<p>Also comment out the line you wrote to print out one of the items.</p>

<p>Your file should look like:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11</pre></td><td class="code"><pre>#Load Libraries
from dpla.api import DPLA

#Set Variables
dpla = DPLA('YourKeyHere')
# result = dpla.search('cooking', fields=['sourceResource'], page_size = 50)

# Define Functions

# Make Function Calls
# print result.items[39]
</pre></td></tr></tbody></table>
</div>

<p>Now, let's create a new variable, "<code>all_records</code>" and set it equal to an empty list.</p>

<p>To do this, add a new line to the variables section of the code:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>all_records = []
</pre></td></tr></tbody></table>
</div>

<p>This tells the computer that we have a variable, "<code>all_records</code>", that this variable will hold a list, and that we currently have no items in that list.</p>

<p>Now that we have a place to store our values, we now have to tell the computer to get the search results from each page and save those results to the "all_records" list.</p>

<p><span class="left"><a href="module05.html">Previous Module</a></span>
<span class="right"><a href="module07.html">Next Module</a></span></p>

  <h3><a href="/modules/module05.html">Write Python in Script Files</a></h3>
  <!-- use article.summary(250) if you have Nokogiri available to show just
       the first 250 characters -->
  <p>In this module, we will learn:</p>

<ol>
  <li>To write and execute a Python script in the Terminal</li>
  <li>To organize our script files</li>
  <li>How a programming language relates to our machines and to the available libraries</li>
</ol>

<p>In this module, we will look at how to save our Python scripts in a text file. While the Interactive Shell is really useful for figuring things out, files are easier to share and enable us to keep our save our work as we go.</p>

<h3 id="writing-and-executing-script-files">1. Writing and Executing Script Files</h3>

<p>First, exit out of the Python Interactive Shell by running <span class="command">exit()</span>.</p>

<p>You should still be in the folder we made at the beginning of the day. Check using <span class="command">pwd</span>.</p>

<p>Now remember we created a file called "my_first_script.py"? Let's open that file again and remind ourselves of what we wrote.</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>open my_first_script.py
</pre></td></tr></tbody></table>
</div>

<p>and on Windows:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>Start Notepad++ my_first_script.py
</pre></td></tr></tbody></table>
</div>

<p>It should say 'print "Hello World"'. Now that you know something about Python functions, what do you expect this script to do?</p>

<p>Let's test it out! To execute a Python file, run the following in Terminal:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>python my_first_script.py
</pre></td></tr></tbody></table>
</div>

<p>Your Terminal window should look something like:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre>jeriwieringa$ python my_first_script.py
Hello World
jeriwieringa$
</pre></td></tr></tbody></table>
</div>

<p>Congratulations! You just executed your first Python script!</p>

<h3 id="writing-our-dpyla-script">Writing our DPyLA Script</h3>

<p>Now let's recreate some of the work we did in the Interactive Shell in this script file.</p>

<p>Delete <span class="command">print "Hello World"</span> so that you're working with a clean file.</p>

<p>First, at the beginning of a Python file you need to list the libraries that we will be using. The computer will execute the code in the order it reads it, so it is important that your commands follow a logical structure down the page.</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>from dpla.api import DPLA
</pre></td></tr></tbody></table>
</div>

<p>Then we need to store our API key:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>dpla = DPLA('YourAPIKey')
</pre></td></tr></tbody></table>
</div>

<p>Then we can write our search query:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>result = dpla.search('cooking')
</pre></td></tr></tbody></table>
</div>

<p>Your file should look like this:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre>from dpla.ap import DPLA

dpla = DPLA('YourAPIKey')
result = dpla.search('cooking')
</pre></td></tr></tbody></table>
</div>

<p>Save the file and go back to Terminal. Run:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>python my_first_script.py
</pre></td></tr></tbody></table>
</div>

<p>You should notice that your computer works awhile and then returns to normal, but doesn't tell you anything about what it did. To see results, we can use the print function again.</p>

<p>Open your script file again (<span class="command">open my_first_script.py</span>or <span class="command">Start notepad++ my_first_script.py</span>).</p>

<p>Print is a very useful tool for checking on your script as it moves through your commands. You can use "print" to make sure your query is returning what you wanted, that your code is parsing as you expect, and to identify where things go wrong.</p>

<h3 id="group-challenge">Group Challenge</h3>

<p>Work with your group to add another line to the file that uses the "print" function to display one item from your search.</p>

<p>Work with your table to add comments to the lines in 'my_first_script.py'</p>

<h3 id="programming-languages">3. Programming Languages</h3>

<p>It is time to return to the pen and paper! Work with your group and your coach to talk about Python as a programming language and how it fits in the ecosystem of your computer.</p>

<p>*Python 3 does require the use of () for print, making it more consistent with the Python syntax for functions.</p>

<p><span class="left"><a href="module04.html">Previous Module</a></span>
<span class="right"><a href="module06.html">Next Module</a></span></p>

  <h3><a href="/modules/module04.html">Working with the API</a></h3>
  <!-- use article.summary(250) if you have Nokogiri available to show just
       the first 250 characters -->
  <p>In this module, you will learn:</p>

<ol>
  <li>To read API documentation to understand the possible queries</li>
  <li>To limit search results with different variables</li>
</ol>

<p>Now that we've learned to make a simple request using the DPyLA library, let's spend some time exploring the different kinds of requests we can make. </p>

<h3 id="constructing-api-requests">Constructing API Requests</h3>

<p>Open up the <a href="https://github.com/bibliotechy/DPyLA">documentation for the DPyLA library</a> and for the <a href="http://dp.la/info/developers/codex/requests/">DPLA API</a>.</p>

<p>First, let's get some contextual data about the search results. In the Python Interactive Shell, run <span class="command">result.count</span>. This tells you how many total items fit the search term. </p>

<p>Now run <span class="command">result.limit</span>. This tells you how many results the API returned. By default, the API will give you 10 results at a time. Look at the DPyLA documentation and try to construct a request that gets you 50 results.</p>

<p>You can also limit your search results with a variety of variables. </p>

<p>For example, you can be more specific with your search, such as limiting your query to cooking in the title of an item. </p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>result = dpla.search("cooking", fields=["sourceResource.title", "sourceResource.date", "sourceResource.spatial"])
</pre></td></tr></tbody></table>
</div>

<p>To see your updated search results, run:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>result.items[0:3]
</pre></td></tr></tbody></table>
</div>

<p>You can also sort by geography:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>result = dpla.search("cooking", fields=["sourceResource.title", "sourceResource.date", "sourceResource.spatial"], spatial_facet=[37.7577,-122.4376])
</pre></td></tr></tbody></table>
</div>

<p>To see the results, run:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>result.items[0:3]
</pre></td></tr></tbody></table>
</div>

<p>These types of commands help you focus the search results so that you have less noisy data – so that more of the data fits the questions you want to ask.</p>

<p>Work with the documentation and your table to construct some more targeted queries. </p>

<ul>
  <li>How would you narrow the data for different questions? What variables would you use?</li>
  <li>Do you see any additional strengths or weaknesses with the data when trying to limit your search results?</li>
</ul>

<h3 id="group-challenge">Group Challenge</h3>

<p>How would you save one of your limited searches to a different variable? How then would you show the items?</p>

<p><span class="left"><a href="module03.html">Previous Module</a></span>
<span class="right"><a href="module05.html">Next Module</a></span></p>

  <h3><a href="/modules/module03.html">Getting Data</a></h3>
  <!-- use article.summary(250) if you have Nokogiri available to show just
       the first 250 characters -->
  <p>In this module, you will learn:</p>

<ol>
  <li>To install new libraries using <code>pip</code></li>
  <li>To use the Python Interactive Shell to run basic Python commands</li>
  <li>To load the DPyLA library and make an API request</li>
</ol>

<p>So far, we have looked at the data in our browser and have a sense of the scope of the information we can work with and the questions we might want to ask.  </p>

<p>In this module, we will use <code>pip</code> to install the DPyLA Python library, which will make it easy to use the DPLA API on our machines. We will also begin writing our first lines of Python to interact with that data using the Python Interactive Shell.</p>

<h3 id="install-dpyla-library">1. Install DPyLA Library</h3>

<p>We talked earlier about libraries, those bundles of code that we can load and use in creating our own scripts. Just like in cooking, it is possible to make everything from scratch. However, this is often not necessary, nor is it the most efficient way to get the same results. </p>

<p>The <a href="https://github.com/bibliotechy/DPyLA">DPyLA</a> library makes it easy to work with the DPLA API.</p>

<p>We can easily get this library for use with our own code using <code>pip</code>.</p>

<p>Type <span class="command">pip install dpla</span>. </p>

<p>If you get a permissions error and you're a Mac user, type <span class="command">sudo pip install dpla</span> and enter your password. If you get a permissions error and you're a Windows user, type <span class="command">Start-Process powershell -Verb runAs</span> to open Powershell as an administrator, then type <span class="command">pip install dpla</span>.</p>

<p>You have just installed your first Python library.</p>

<h3 id="introducing-the-python-interactive-shell">2. Introducing the Python Interactive Shell</h3>

<p>Python is a language we can use to write and execute scripts. But it also comes with a handy feature called the Interactive Shell. Using the Interactive Shell, we will first experiment with lines of Python and see what the language can do. </p>

<p>To start up the Interactive Shell, go to your Terminal window and type <span class="command">python</span> and press "Enter".</p>

<p>Your Terminal should now look like this:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre>jeriwieringa$ python
Python 2.7.5 (default, Mar  9 2014, 22:15:05)
[GCC 4.2.1 Compatible Apple LLVM 5.0 (clang-500.0.68)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt;
</pre></td></tr></tbody></table>
</div>

<p>Everything you type now will be processed by Python. Let's try it out a bit. Type <span class="command">print "Hello World"</span> and press "Enter". Now type <span class="command">print "My Name is [Your Name]"</span> and press "Enter". Now type <span class="command">print 5 + 8</span> and press "Enter".</p>

<p>Here you have discovered a couple of very useful things about programming languages. </p>

<p>"print" is a function in Python that returns whatever follows it next. </p>

<p>The content contained inside the " " marks is called a string. This is especially important for humanities research, because often when we work with texts, or metadata, we are working with strings.</p>

<p>Finally, if we input numbers or equations into Python, it will compute them. If you don't want Python to compute, you should treat the numbers like a string. Experiment in the Interactive Shell to see if you can get it to display <span class="command">5 + 8</span> rather than <span class="command">13</span>.</p>

<h3 id="loading-dpyla-in-the-shell-and-make-an-api-request">3. Loading DPyLA in the Shell and Make an API Request</h3>

<p>Let's start using our new DPyLA library to make an API call to the DPLA. Following the <a href="https://github.com/bibliotechy/DPyLA">library documentation</a>, run:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>from dpla.api import DPLA 
</pre></td></tr></tbody></table>
</div>

<p>You just loaded the DPyLA library into your Python Shell, making all of its code available for you to use.</p>

<p>Next run:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>dpla = DPLA('your-key-here')
</pre></td></tr></tbody></table>
</div>

<p>What you have just done is create what is called a "variable"– dpla –that stores your API key.</p>

<p>Next run:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>result = dpla.search('cooking')
</pre></td></tr></tbody></table>
</div>

<p>You have just created a new variable, "result", that stores the result of a DPLA search for "cooking". Now, you might be wondering what happened to your API key. This is part of the magic of using a library. When you save your key as "dpla", you make it known to the library. Then, when you call "dpla.search", you're combining your key with code in the DPyLA library that then executes the search and saves all of the data in a new variable called "result". </p>

<p>But we still haven't seen any of the results from the API. To show the results, run:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>result.items
</pre></td></tr></tbody></table>
</div>

<p>You should see something like this:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>[{u'_id': u'digitalnc--urn:brevard.lib.unc.eduecu_c5:oai:digital.lib.ecu.edu/7394', u'admin': {u'sourceResource': {u'title': u'Cooking'}, u'validation_message': None, u'valid_after_enrich': True}, u'sourceResource': {u'isPartOf': [u'https://digital.lib.ecu.edu/encore/ncgre000/00000008/00007394/00007394_tn_0001.gif'], u'description': [u'Boys and girls cooking during home economics class. Dates from negative sleeve.'], u'language': [{u'iso639_3': u'eng', u'name': u'English'}], u'rights': u'Copyright held by Joyner Library. Permission to reuse this work is granted for all non-commercial purposes.', u'@id': u'http://dp.la/api/items/7cb32765b538a57a35fbdbfad03be57b#sourceResource', u'format': u'negatives (photographic)'
</pre></td></tr></tbody></table>
</div>

<p>You just asked the computer to give you all of the items it got back from the search for "cooking". </p>

<p>Notice the structure of this data. Can you find the key:value pairs? </p>

<p>You might notice the " u' " in front of each string. This is a feature of Python 2. The u' indicates that what follows is a unicode string. Don't worry too much about what that means - it is information about how the data is being encoded - but if you want to really geek out, you can read all about encoding in the <a href="https://docs.python.org/2/tutorial/introduction.html#unicode-strings">language documentation</a>.</p>

<p>But what if you only want to see one item at a time?</p>

<p>The information you get back from the DPLA API comes in the form of an <strong>array</strong>, or <strong>list</strong> ("array" is the general programming word for a series of things, "list" is Python's name for a series of things). Lists are super powerful, enabling us to load up a lot of information and then work through each bit individually.</p>

<p>One general thing we can do with lists is get items according to their position in the list. </p>

<p>For example, if you want the first item only:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>result.items[0]
</pre></td></tr></tbody></table>
</div>

<p>You should now see a much smaller dump of data. You might be wondering why we used 0. Programming languages start counting with 0 rather than one.</p>

<p>Try to get the 3rd item in the search results. </p>

<h3 id="group-challenge">Group Challenge</h3>

<p>Can you use <a href="http://effbot.org/zone/python-list.htm">this tutorial</a> to figure out how to get items 1 - 3?	</p>

<p><span class="left"><a href="module02.html">Previous Module</a></span>
<span class="right"><a href="module04.html">Next Module</a></span></p>

  <h3><a href="/modules/module02.html">Thinking about Data</a></h3>
  <!-- use article.summary(250) if you have Nokogiri available to show just
       the first 250 characters -->
  <p>In this module, we will learn:</p>

<ol>
  <li>to use cURL or Invoke-WebRequest to talk to a server</li>
  <li>to use an API to request data</li>
  <li>to read JSON documents and think about how data can be structured</li>
</ol>

<p>Doing computational work in the humanities requires data. One useful definition of data from the <a href="https://www.lib.umn.edu/datamanagement/whatdata">Univeristy of Minnesota</a> is "[a] reinterpretable representation of information in a formalized manner suitable for communication, interpretation, or processing." While there are different types of data, the data that we can use for computational work is digital data. </p>

<p>Finding useful digital data for humanities research is still a challenge. Fortunately, there are a growing number of institutions making data and metadata of interest to humanities scholars available for use.</p>

<p>For this workshop, we will use data from the <a href="http://dp.la">Digital Public Library of America</a>, which is working to aggregate and make available data from cultural heritage institutions across the United States. We can take this data and use it to find items of interest and trends across the contributing organizations. </p>

<p>To do that, we first need to get a key from the DPLA so that we can gain access to the data. We will then interact with the API through our browsers and examine just what this data looks like to think about the types of questions we can explore using it.</p>

<h3 id="get-an-api-key">1. Get an API Key</h3>

<p>Go to <a href="http://dp.la/info/developers/codex/">http://dp.la/info/developers/codex/</a>. This is the documentation for the DPLA API. Remember from our earlier conversation that an API is an interface that allows computer programs to talk to one another: if you format your request in a particular way, you will get back the data from the server in a particular data format without any surrounding HTML.</p>

<p>First, you will need an API key. </p>

<p>If you are on a Mac, there is a utility built into your system called "cURL". To use cURL to request your key, type:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>curl -v -XPOST http://api.dp.la/v2/api_key/YOUR_EMAIL@example.com
</pre></td></tr></tbody></table>
</div>

<p>into your Terminal, replacing "YOUR_EMAIL@example.com" with your actual email address.</p>

<p>If you are on Windows, your utility is called "Invoke-WebRequest". To use Invoke-WebRequest to request your key, type:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>Invoke-WebRequest -Uri ("http://api.dp.la/v2/api_key/YOUR_EMAIL@example.com") -Method POST -Verbose 
</pre></td></tr></tbody></table>
</div>

<p>into Powershell, replacing "YOUR_EMAIL@example.com" with your actual email address.</p>

<p>You should get an email from the DPLA with your key. </p>

<h3 id="examining-data-in-browser">2. Examining Data in Browser</h3>

<p>To get a sense of how the API key works and what the data we get back looks like, let's use the web-browser. If you can, please use Chrome.</p>

<p>In your browser, type:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>http://api.dp.la/v2/items?q=cooking&amp;api_key=YOURAPIKEY
</pre></td></tr></tbody></table>
</div>

<p>into Terminal, replacing "YOURAPIKEY" with the key just emailed to you.</p>

<p>The first part of this URL ("http://api.dp.la/v2/") is the "base" URL. This must go at the beginning of all API requests. Next, we are telling the server that we want to see "items" and we want to see the items that match the keyword "cooking". The "?q=" is the grammar of the API – this is how we signal to the server that we want to query for the word following the "=". To see additional options for the API, go to <a href="http://dp.la/info/developers/codex/requests/">http://dp.la/info/developers/codex/requests/</a>.</p>

<p>You should see something that looks like:</p>

<div class="highlight json"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="p">{</span><span class="s2">"count"</span><span class="p">:</span><span class="mi">10646</span><span class="p">,</span><span class="s2">"start"</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="s2">"limit"</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span><span class="s2">"docs"</span><span class="p">:[{</span><span class="s2">"@context"</span><span class="p">:</span><span class="s2">"http://dp.la/api/items/context"</span><span class="p">,</span><span class="s2">"isShownAt"</span><span class="p">:</span><span class="s2">"https://digital.lib.ecu.edu/7394"</span><span class="p">,</span><span class="s2">"dataProvider"</span><span class="p">:</span><span class="s2">"East Carolina University"</span><span class="p">,</span><span class="s2">"@type"</span><span class="p">:</span><span class="s2">"ore:Aggregation"</span><span class="p">,</span><span class="s2">"provider"</span><span class="p">:{</span><span class="s2">"@id"</span><span class="p">:</span><span class="s2">"http://dp.la/api/contributor/digitalnc"</span><span class="p">,</span><span class="s2">"name"</span><span class="p">:</span><span class="s2">"North Carolina Digital Heritage Center"</span><span class="p">},</span><span class="s2">"object"</span><span class="p">:</span><span class="s2">"https://digital.lib.ecu.edu/encore/ncgre000/00000008/00007394/00007394_tn_0001.gif"</span><span class="p">,</span><span class="s2">"ingestionSequence"</span><span class="p">:</span><span class="mi">14</span><span class="p">,</span><span class="s2">"id"</span><span class="p">:</span><span class="s2">"7cb32765b538a57a35fbdbfad03be57b"</span><span class="p">,</span><span class="s2">"ingestDate"</span><span class="p">:</span><span class="s2">"2014-08-19T10:45:46.393447"</span><span class="p">,</span><span class="s2">"_rev"</span><span class="p">:</span><span class="s2">"2-1b21f198053a2727bffece028cd30a6d"</span><span class="p">,</span><span class="s2">"aggregatedCHO"</span><span class="p">:</span><span class="s2">"#sourceResource"</span><span class="p">,</span><span class="s2">"_id"</span><span class="p">:</span><span class="s2">"digitalnc--urn:brevard.lib.unc.eduecu_c5:oai:digital.lib.ecu.edu/7394"</span><span class="w">
</span></pre></td></tr></tbody></table>
</div>

<p>Well done! You have just made a successful API request.</p>

<p>Now try the same thing using a very handy Chrome extension called <a href="https://chrome.google.com/webstore/detail/jsonview/chklaanhfefbnpoihckbnefhakgolnmc">JSONView</a>, which will make the output display look like this:</p>

<div class="highlight json"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14</pre></td><td class="code"><pre><span class="p">{</span><span class="w">
</span><span class="err">count</span><span class="p">:</span><span class="w"> </span><span class="mi">10646</span><span class="p">,</span><span class="w">
</span><span class="err">start</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="err">limit</span><span class="p">:</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w">
</span><span class="err">docs</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
	</span><span class="p">{</span><span class="w">
	</span><span class="err">@context</span><span class="p">:</span><span class="w"> </span><span class="s2">"http://dp.la/api/items/context"</span><span class="p">,</span><span class="w">
	</span><span class="err">isShownAt</span><span class="p">:</span><span class="w"> </span><span class="s2">"https://digital.lib.ecu.edu/7394"</span><span class="p">,</span><span class="w">
	</span><span class="err">dataProvider</span><span class="p">:</span><span class="w"> </span><span class="s2">"East Carolina University"</span><span class="p">,</span><span class="w">
	</span><span class="err">@type</span><span class="p">:</span><span class="w"> </span><span class="s2">"ore:Aggregation"</span><span class="p">,</span><span class="w">
	</span><span class="err">provider</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
		</span><span class="err">@id</span><span class="p">:</span><span class="w"> </span><span class="s2">"http://dp.la/api/contributor/digitalnc"</span><span class="p">,</span><span class="w">
		</span><span class="err">name</span><span class="p">:</span><span class="w"> </span><span class="s2">"North Carolina Digital Heritage Center"</span><span class="w">
	</span><span class="p">},</span><span class="w">
</span></pre></td></tr></tbody></table>
</div>

<h3 id="thinking-about-json">3. Thinking about JSON</h3>

<p>What you are looking at is a JSON document. In JSON, all the information is given in "key : value" pairs. On the left-hand side is the "key". This is a standardized description of bits of information, such as "provider" or "ingestData". On the right-hand side is the "value", or the information that applies for a particular item. With your table, look at the JSON document in your browser and try to answer the following questions:</p>

<ol>
  <li>Look at the search results: how many objects are displayed here? How do you know?</li>
  <li>How many objects in the DPLA database fit the query for cooking?</li>
  <li>What questions might you ask of this dataset? Which key:value pairs would be most helpful for answering those questions?</li>
  <li>What questions would be hard to answer with this dataset? What additional information would you need?</li>
</ol>

<p><span class="left"><a href="module01.html">Previous Module</a></span>
<span class="right"><a href="module03.html">Next Module</a></span></p>

  <h3><a href="/modules/module01.html">Working with Your Computer</a></h3>
  <!-- use article.summary(250) if you have Nokogiri available to show just
       the first 250 characters -->
  <p>In this module, we will learn:</p>

<ol>
  <li>To navigate and manipulate your computer using the Terminal </li>
  <li>To conceptualize your computer as a computing machine connected to other computing machines</li>
</ol>

<h3 id="working-with-the-terminal">1. Working with the Terminal</h3>

<p>Throughout this tutorial, we will be spending a lot of time in Terminal/PowerShell as our primary way of talking to our computers. In order to do this, however, it is necessary to take some time to get comfortable working with the command line.</p>

<p>So let's walk through some basic commands while setting up our computer for the rest of the tutorial.</p>

<p>First, open Terminal/PowerShell and let's get a sense of where we are in the file structure of our computer. </p>

<p>Type <span class="command">pwd</span> and press "Enter". </p>

<p>The command, which stands for "print working directory", tells you which directory you are in. Navigating the computer through the Terminal sometimes feels like tunneling, and <span class="command">pwd</span> is very helpful for checking where you are at any given time. You should see something like:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>/Users/yourusername
</pre></td></tr></tbody></table>
</div>

<p>if you're on a Mac or</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>C:\Users\username
</pre></td></tr></tbody></table>
</div>

<p>for Windows.</p>

<p>Type <span class="command">ls</span> and press "Enter". </p>

<p>This is another helpful command for orienting yourself. This command lists all the files in your current directory. If you need to see hidden files, type <span class="command">ls -a</span> (Mac) or <span class="command">ls -Hidden</span> (Windows). </p>

<p>You should see something like:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre>jeris-mbp:~ jeriwieringa$ ls
Applications		Dropbox		Music
Desktop			Envs		Pictures
Documents		Library		Public
Downloads		Movies		Sites		
</pre></td></tr></tbody></table>
</div>

<p>Now that we know where we are, we need to learn how to move around the different folders. This is done with <span class="command">cd</span> or "change directory". If you just type <span class="command">cd</span>, you will move back to the root of your user directory. To move forward, type:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>cd [Directory_Name]
</pre></td></tr></tbody></table>
</div>

<p>and press Enter. </p>

<p>You can also move multiple directories at a time with:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>cd [Directory_Name/Directory_Name/Directory_Name]
</pre></td></tr></tbody></table>
</div>

<p>This way you can dig down through your files. Go ahead and give it a try.</p>

<p>Type <span class="command">cd Documents</span> and press Enter. Now type <span class="command">ls</span> and press Enter.</p>

<p>You can also move backwards by typing <span class="command">cd ../</span>. To move back multiple directories, type <span class="command">cd ../../../</span>. </p>

<p>Go ahead and give that a try. After moving around, work your way back to the "Documents" folder. </p>

<p>Let's create a folder for our work today. </p>

<p>Type <span class="command">mkdir dhb_awesome</span> and press Enter. Now type <span class="command">ls</span> and you should see your "dhb_awesome" folder. Use <span class="command">cd</span> to move into that folder.</p>

<p>Folders are great but it is also helpful to know how to make files. For that, we'll use a command called "touch" on OSX and "New-Item" on Windows.</p>

<p>If you're on a Mac, type:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>touch my_first_script.py
</pre></td></tr></tbody></table>
</div>

<p>and press Enter. </p>

<p>If you're on Windows, type:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>New-Item -ItemType file my_first_script.py
</pre></td></tr></tbody></table>
</div>

<p>and press Enter. </p>

<p>Run <span class="command">ls</span> to see the file you just created. </p>

<p>To edit your new file in your text-editor, type: </p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>open my_first_script.py
</pre></td></tr></tbody></table>
</div>

<p>on your Mac or</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>Start notepad++ my_first_script.py
</pre></td></tr></tbody></table>
</div>

<p>on your Windows machine. </p>

<p>This should launch your default text editor. (For Mac users, if the file does not open in TextWrangler or your text editor, work with your coach to set your default editor.) </p>

<p>Type <span class="command">print "Hello World"</span> into the text file and save. We will do something with that soon.</p>

<p>If you want to learn more commands–like how to remove, copy, or rename files–checkout the <a href="http://praxis.scholarslab.org/scratchpad/bash/">Scholars' Lab Command Line Bootcamp</a>. But this is enough to start!</p>

<h3 id="terminology-and-mapping-the-computer">2. Terminology and Mapping the Computer</h3>

<p>Now we're going to take a step back to think about the different layers of the computer that we will be working with and about how we move data from one process to another. </p>

<p>We will talk more about moving from the graphical interface to the terminal interface for communicating with our computers. Then we will talk about using APIs (or Application Programming Interfaces) for communicating between computers.</p>

<h3 id="credits">Credits</h3>
<p>This tutorial is based on the <a href="http://praxis.scholarslab.org/scratchpad/bash/">Praxis Program's Command Line Bootcamp</a> and Greg Bloom's post, <a href="http://sunlightfoundation.com/blog/2014/06/20/opengov-voices-draw-an-api-an-interpretation-of-open-data-by-tcampers/">Draw an API</a>.</p>

<p><span class="right"><a href="module02.html">Next Module</a></span></p>

  <h3><a href="/modules/installation.html">Installation</a></h3>
  <!-- use article.summary(250) if you have Nokogiri available to show just
       the first 250 characters -->
  <p>Welcome to DH Bridge. This one day workshop will introduce you to basic programming concepts for use in humanities research. We will be working with Python, a programming language that combines a human-readable syntax with robust support for statistical analysis and graphing. The data for the day will be gleaned from the Digital Public Library of America. </p>

<h3 id="step-one-required-supplies">Step One: Required Supplies</h3>

<p>For the workshop you will need to bring:</p>

<ul>
  <li><strong>Your Laptop:</strong>
    <ul>
      <li>You need to have a working WiFi connection (we will provide access to Mason's wireless)</li>
      <li>We recommend that you update your operating system to at least Mavericks or Mountain Lion if running a Mac (no need to rush to Yosemite though), if your machine can support it. While you should be able to work through the tutorials on an older operating system, the odds of unexpected bugs and software incompatability increases with older operating systems. </li>
      <li>We recommend that you install the Chrome browser, as we will be using some Chrome extensions along the way.</li>
    </ul>
  </li>
  <li><strong>Your Powercord</strong></li>
</ul>

<p>You might also want to bring:</p>

<ul>
  <li>An Extension Cord</li>
  <li>Snacks</li>
</ul>

<h3 id="step-two-overview">Step Two: Overview</h3>

<p>You will be installing or checking the status of the following tools:</p>

<ul>
  <li>Python</li>
  <li><code>pip</code></li>
  <li>Text Editor</li>
</ul>

<p>Programming languages are very literal: if you tell it to do something that it cannot do, it just stops and gives you an error. So don't worry if you get an error message–it happens all the time, often over very small, correctable things. </p>

<h3 id="a-note-on-python-versions">A Note on Python Versions</h3>
<p>For this workshop, we will be using Python 2.7. This is for two reasons: first, using the default Python version enables us to teach basic programming concepts without the additional complexity of managing Python versions; and second, most of the existing tutorials for learning Python, including <em>The Programming Historian</em> and <em>Learn Python the Hard Way</em>, still use 2.7. Starting with 2.7 will enable you to use these materials smoothly. We would like to also offer a Python3 version of this tutorial, so that those who wish to start with the newer syntax can do so.</p>

<h3 id="step-three-install-go-to-your-operating-system-below">Step Three: Install (Go To Your Operating System Below)</h3>

<ul>
  <li><a href="#mac">Mac</a></li>
  <li><a href="#windows">Windows</a></li>
</ul>

<h3 id="mac">Mac</h3>

<h4 id="install-text-editor">1. Install Text Editor</h4>

<p>For this tutorial, we recommend using TextWrangler, which is a free editor from BareBones software. To get TextWrangler, go to <a href="http://www.barebones.com/products/textwrangler/">http://www.barebones.com/products/textwrangler/</a> and download. </p>

<p>We recommend keeping TextWrangler in your dock so that it is easy to access.</p>

<p>You are welcome to use another text editor if you wish. Just make sure that it is a plain text editor (do not use Word).</p>

<h4 id="check-your-python-version">2. Check your Python Version</h4>
<p>Search your computer for "Terminal." This program allows you to give your computer commands without using the interface. Select to keep Terminal in your dock. </p>

<p>Open up Terminal. It should give you a screen that looks similar to this: </p>

<p><img alt="image of terminal screen" src="../images/terminal.png" /></p>

<p>To check your Python version, type <span class="command">python</span> into the Terminal window and press "Enter". You should see something that looks like:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre>Python 2.7.5 (default, Mar  9 2014, 22:15:05) 
[GCC 4.2.1 Compatible Apple LLVM 5.0 (clang-500.0.68)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; 
</pre></td></tr></tbody></table>
</div>

<p>Make note of your Python version. </p>

<p>You are now in the Python Shell. This is an interactive environment that allows you to give Python commands directly inside Terminal. We will come back to this during the workshop.</p>

<p>Exit the Python Shell by typing <span class="command">quit()</span> and pressing "Enter".</p>

<h4 id="install-pip">3. Install <code>pip</code></h4>

<p>One of the things that makes Python so powerful is the ability to use libraries, or packages of code, and to combine these together in our own programs. <code>pip</code> is a tool that helps us install and use those packages of code.</p>

<p>To download <code>pip</code>, we are going to use another tool called cURL, which is already part of your operating system. cURL allows us to transfer data using the command line.</p>

<p>Type <span class="command">curl -O https://bootstrap.pypa.io/get-pip.py</span> and press "Enter". This will download a file titled "get-pip.py" onto your machine.</p>

<p>To install <code>pip</code>, you need to run that file with Python. To do that, type <span class="command">python get-pip.py</span> into Terminal and press "Enter". </p>

<p>If Terminal turns red and you get errors that say <span class="command"> OSError: [Errno 13] Permission denied</span>, don't fret. This is because the script is trying to make changes to system files, and your computer is protecting those files. Because we trust this script, we can over-ride those protections and give Python permission to install at the system level. We do this by using the sudo command (or "SuperUserDO") before the Python command.</p>

<p>Type <span class="command">sudo python get-pip.py</span> into the Terminal window.</p>

<p>The computer will prompt you for your password. This is the password you use to log onto your computer. Terminal will give no indication that you are typing as you enter your password.</p>

<p>If everything goes well, you should see something similar to the following in your Terminal window:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre>Downloading/unpacking pip from https://pypi.python.org/packages/py2.py3/p/pip/pip-1.5.6-py2.py3-none-any.whl#md5=4d4fb4b69df6731c7aeaadd6300bc1f2
  	Downloading pip-1.5.6-py2.py3-none-any.whl (1.0MB): 1.0MB downloaded
Installing collected packages: pip
Successfully installed pip
Cleaning up...
</pre></td></tr></tbody></table>
</div>

<p>To check that everything installed, type <span class="command">pip</span> into Terminal and press "Enter". This will give you information on the different commands that are available for you to use with "pip".</p>

<h4 id="well-done-your-computer-is-now-ready-for-the-workshop">Well done! Your computer is now ready for the workshop!</h4>

<h3 id="windows">Windows</h3>

<h4 id="install-text-editor-1">1. Install Text Editor</h4>

<p>For this tutorial, we recommend using NotePad++, which is free to use. To get Notepad++, go to <a href="http://notepad-plus-plus.org/">http://notepad-plus-plus.org/</a> and download. </p>

<p>To easily access NotePad++, be sure to add a shortcut to your Desktop and/or Quick Launch.</p>

<h4 id="install-python">2. Install Python</h4>

<p>Search your computer for "PowerShell." This program allows you to give your computer commands without using the interface. </p>

<p>Open up PowerShell. It should give you a screen that looks similar to this: </p>

<p><img alt="image of Powershell screen" src="../images/powershell.png" /></p>

<p>In PowerShell, type <span class="command">python</span> and press "Enter". You will most likely get back a message that says <span class="command">python is not recognized..</span>.</p>

<p>If this is the case, download and install Python from <a href="https://www.python.org/download/">https://www.python.org/download/</a>. Choose the "Python 2.7.8 Windows Installer" or "Python 2.7.8 Windows X86-64 Installer", depending on your system. Run the installer and accept the default settings.</p>

<p>Once Python is installed, you will have to tell the computer where to look for it. In PowerShell, enter:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>[Environment]::SetEnvironmentVariable("Path", "$env:Path;C:\Python27", "User")
</pre></td></tr></tbody></table>
</div>

<p>Close PowerShell and re-open it. To check if Python installed properly, type <span class="command">python</span> and press "Enter". You should get something that looks like this back:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre>Python 2.7.8  (default, Jun 30 2014, 14:24) [MSC v.1500 32 bit (Intel)] on win32
Type "help", "copyright", "credits" or license for more information.
&gt;&gt;&gt; 
</pre></td></tr></tbody></table>
</div>

<p>You are now in the Python Shell. This is an interactive environment that allows you to give Python commands directly inside PowerShell. We will come back to this during the workshop.</p>

<p>To exit the Python Shell, type <span class="command">quit()</span> and press "Enter".</p>

<h4 id="install-pip-1">3. Install <code>pip</code></h4>

<p>One of the things that makes Python so powerful is the ability to use libraries, or packages of code, and to combine these together in our own programs. <code>pip</code> is a tool that helps us install and use those packages of code.</p>

<p>The easiest way to install <code>pip</code> is through the use of a Python program called get-pip.py. </p>

<p>First, make a new directory "envs" at your root level:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>mkdir c:\envs
</pre></td></tr></tbody></table>
</div>

<p>Move into that directory:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>cd c:\envs
</pre></td></tr></tbody></table>
</div>

<p>Enter the following to download "get-pip.py":  </p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>(new-object System.Net.WebClient).DownloadFile('https://raw.github.com/pypa/pip/master/contrib/get-pip.py', 'c:\envs\get-pip.py')
</pre></td></tr></tbody></table>
</div>

<p>Finally, enter the following to install the "get-pip.py" script:</p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>python c:\envs\get-pip.py  
</pre></td></tr></tbody></table>
</div>

<p>Now typing <span class="command">pip</span> should work. If it doesn’t, that means the Scripts folder is not in your path. Run the next command in that case (Note that this command must be run only once or your PATH will get longer and longer). </p>

<div class="highlight plaintext"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>setx PATH "%PATH%;C:\Python27\Scripts"
</pre></td></tr></tbody></table>
</div>

<p>Next, close and re-open PowerShell. </p>

<p>To test, run <span class="command">pip</span> in PowerShell.</p>

<h3 id="credits">Credits</h3>
<p>These instructions are modifications of the Python installation instruction at <a href="http://learnpythonthehardway.org/book/ex0.html"><em>Learn Python the Hard Way</em></a> and Fred Gibb's <a href="http://fredgibbs.net/tutorials/tutorial/install-python-modules/">tutorial on installing <code>pip</code></a> as well as the <a href="http://docs.railsbridge.org/installfest/">InstallFest docs of RailsBridge</a>.</p>




                </section>
              </article>
  			   </div>
  		</div>
  		
  		<footer>
  				<div class="wrap">
		<div id="rights">
		    <p>&copy; CC-BY 2014</p>
		    <p>The DH Bridge curriculum is supported by a microgrant from the <a href="http://ach.org/"><img src="http://dhbridge.org/images/ach-logo.png" width=50px ></a></p>
		</div>

	    <div id="contact">
	        <a href="mailto:bridgingdh@gmail.com"><i class="fa fa-paper-plane"></i></a>
	        <a href="https://twitter.com/dhbridge"><i class="fa fa-twitter"></i></a>
	        <a href="https://github.com/dhbridge/curriculum"><i class="fa fa-github"></i></a>
	    </div>
	</div>
  		</footer>

  </body>
</html>