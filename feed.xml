<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog Name</title>
  <subtitle>Blog subtitle</subtitle>
  <id>http://blog.url.com/modules</id>
  <link href="http://blog.url.com/modules"/>
  <link href="http://blog.url.com/feed.xml" rel="self"/>
  <updated>2014-09-18T20:00:00-04:00</updated>
  <author>
    <name>Blog Author</name>
  </author>
  <entry>
    <title>Create Data from Text Files</title>
    <link rel="alternate" href="http://blog.url.com/modules/module12-create.html"/>
    <id>http://blog.url.com/modules/module12-create.html</id>
    <published>2014-09-18T20:00:00-04:00</published>
    <updated>2014-09-25T17:35:57-04:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;In this module, we will be thinking about how we can use the skills we just learned to create data from our primary source material. &lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Looping through the Pages</title>
    <link rel="alternate" href="http://blog.url.com/modules/module09-whileloop.html"/>
    <id>http://blog.url.com/modules/module09-whileloop.html</id>
    <published>2014-09-18T20:00:00-04:00</published>
    <updated>2014-10-11T16:54:00-04:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;In this module, we will add another loop to our "pull records" function that allows us to move through more than one page of search results.&lt;/p&gt;

&lt;h3 id="introducing-the-while-loop"&gt;Introducing the While Loop&lt;/h3&gt;

&lt;p&gt;The "for loop" allows us to do something to each item in a list. The "while loop" is a powerful tool that tells the computer to continue doing something as long as some criteria is true. We can use the while loop and a "counter" to work through all of the pages of search results.&lt;/p&gt;

&lt;p&gt;To use a while loop, let's look again at our "pull records" function.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def pull_records(pages, end, size):
	paged_search = dpla.search(q='cooking', page_size=size, page=pages)
	save_each(paged_search)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remember, "pages" stands for the first page and "end" stands for the last page of search results we want. We want this function to run for every page of search results. In other words, if the page number is less than or equal to the total number of pages available, we want to get the search results from that page. Once we hit the end, we want to stop.&lt;/p&gt;

&lt;p&gt;To write this logic in code, we will add:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while(pages &amp;lt;= end):
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;so that our function now looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def pull_records(pages, end, size):
	while(pages &amp;lt;= end):
		paged_search = dpla.search(q='cooking', page_size=size, page=pages)
		save_each(paged_search)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="adding-a-counter"&gt;Adding a Counter&lt;/h3&gt;

&lt;p&gt;Can you see the problem with our current function? As it currently stands, "pages" is always less than "end" because it never increases. This means we would get stuck in an "infinite loop" if we tried to run the code right now.&lt;/p&gt;

&lt;p&gt;To avoid the infinite loop, we need to increase the value of "pages" each time we work through the loop. We can do this by overwriting the value of "pages" to be "pages + 1".&lt;/p&gt;

&lt;p&gt;After &lt;span class="command"&gt;save_each(paged_search)&lt;/span&gt; add:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pages = pages + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let's also add a print command to check that things are working as we expect. Above &lt;span class="command"&gt;pages = pages + 1&lt;/span&gt; add:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print "finished page " + str(pages)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our file should now look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from dpla.api import DPLA

dpla = DPLA('Your-Key-Here')

# result = dpla.search('cooking')
# print result.items[1]

all_records = []

def pull_records(pages, end, size):
	while(pages &amp;lt;= end):
		paged_search = dpla.search(q='cooking', page_size=size, page=pages)
		save_each(paged_search)
		print "finished page " + str(pages)
		pages = pages + 1

def save_each(n):
	for each in n.items:
		all_records.append(each)

pull_records(2, 3, 50)

print all_records[40]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let's test our function on a subset of the pages. Change &lt;span class="command"&gt;pull_records(2, 3, 50)&lt;/span&gt; to &lt;span class="command"&gt;pull_records(2, 5, 50)&lt;/span&gt; and change &lt;span class="command"&gt;print all_records[40]&lt;/span&gt; to &lt;span class="command"&gt;print all_records[150]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Save and run in Terminal.&lt;/p&gt;

&lt;h3 id="what-we-learned"&gt;What We Learned:&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;To use a while loop and counter&lt;/li&gt;
  &lt;li&gt;To test on a subset of the data&lt;/li&gt;
  &lt;li&gt;To use "print" to check our functions along the way&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Functions and Loops</title>
    <link rel="alternate" href="http://blog.url.com/modules/module08-functionsandloops.html"/>
    <id>http://blog.url.com/modules/module08-functionsandloops.html</id>
    <published>2014-09-18T20:00:00-04:00</published>
    <updated>2014-10-11T16:17:55-04:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;We now have a file that looks as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from dpla.api import DPLA

dpla = DPLA('Your-Key-Here')

# result = dpla.search('cooking')
# print result.items[1]

all_records = []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will now add a function that handles the query for any given page number.&lt;/p&gt;

&lt;h3 id="creating-a-pull-records-function"&gt;Creating a "Pull Records" Function&lt;/h3&gt;

&lt;p&gt;To write a function, we set of the function with the word "def" and then indent all of the commands that are part of the function.&lt;/p&gt;

&lt;p&gt;In your "my_first_script.py" file, add the line&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def pull_records(pages, end, size):
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You have declared a pull_records function, told the computer that this function will involve three variables (pages, end, and size) and are now ready to add the steps involving in getting the search records. These three variables are arbitrary (you could name them "snap", "crackle", and "pop") but will stand for the first page, the last page, and the number of items per page.&lt;/p&gt;

&lt;p&gt;Tab in one space on the next line and type:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;paged_search = dpla.search(q='cooking', page_size=size, page=pages)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Your file should now look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from dpla.api import DPLA

dpla = DPLA('Your-Key-Here')

# result = dpla.search('cooking')
# print result.items[1]

all_records = []

def pull_records(pages, end, size):
	paged_search = dpla.search(q='cooking', page_size=size, page=pages)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is important to note that Python is white-space aware - when writing functions in Python, we use white space to designate what is in a function or within a loop and what is outside of it.&lt;/p&gt;

&lt;p&gt;Let's add a print statement and test out the first stage of this function. At the same tab as "paged_searchâ€¦", add:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print paged_search.items[2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now to run the function, we will call the function name and give it values. On a new line and outside of the function, add the line:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pull_records(2, 3, 50)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Save the file and go to terminal to run it.&lt;/p&gt;

&lt;h3 id="saving-items-to-all-records"&gt;Saving Items to "All Records"&lt;/h3&gt;

&lt;p&gt;You have written and executed your first function! Well done!&lt;/p&gt;

&lt;p&gt;Now we need to add another function to store those results to the empty "all records" array we set up in the last module. While this is not necessary when you only have one page of results, it becomes necessary when you are trying to save from multiple pages.&lt;/p&gt;

&lt;p&gt;To set up our new "Save Each" function, we will define a new function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def save_each(n):
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The 'n' here is again arbitrary. We are telling the function that there is one variable that we will be passing in and to take that variable and plug it in for 'n' throughout the function.&lt;/p&gt;

&lt;p&gt;We now need to add our first loop. With how we currently have framed our request, there are 50 items in our paged_search item. We want to save each of those items separately to the "all_records" list. This means the computer needs to move through each individual item, take the item and add it to "all_records". &lt;/p&gt;

&lt;p&gt;Tabbing in one space on the next line under &lt;span class="command"&gt;def save_each(n):&lt;/span&gt;s add:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for each in n.items:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is called a "for loop". It tells the computer to iterate through each item in the list 'n'. We use n.items because this is the syntax from the DPyLA library. &lt;/p&gt;

&lt;p&gt;Now we tab in one more space and tell the computer what we want done to each item. To add the item to the "all_records" array, we use the "append" command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;all_records.append(each)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The "save each" function should now look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def save_each(n):
	for each in n.items:
		all_records.append(each)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can use this function in our "pull records" function. Currently, our "pull records" looks as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def pull_records (pages, end, size):
	paged_search = dpla.search(q='cooking', page_size=size, page=pages)
	print paged_search.items[2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let's delete the "print paged_search.item[2]" line, because that was just there to check that the first bit worked, and add a call to the "save_each" function, passing in our search results. Where the "print" command used to be, add:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;save_each(paged_search)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our file should now look like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from dpla.api import DPLA

dpla = DPLA('Your-Key-Here')

# result = dpla.search('cooking')
# print result.items[1]

all_records = []

def pull_records(pages, end, size):
	paged_search = dpla.search(q='cooking', page_size=size, page=pages)
	save_each(paged_search)

def save_each(n):
	for each in n.items:
		all_records.append(each)

pull_records(2, 3, 50)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To test this, let's now add a print statement to the end of the file, after the pull_records function has been run, to make sure that the items are going into the "all_records" variable.&lt;/p&gt;

&lt;p&gt;Add:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print all_records[30]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Save and run your script.&lt;/p&gt;

&lt;p&gt;We have made great progress! We now have two functions to handle making the query and saving the results, but we are still only working with one "page" of search results at a time. In the next module, we will add yet another kind of loop in order to move through the different pages.&lt;/p&gt;

&lt;h3 id="what-we-learned"&gt;What We Learned&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;To create and call functions&lt;/li&gt;
  &lt;li&gt;To pass variables into functions&lt;/li&gt;
  &lt;li&gt;To create a "for loop"&lt;/li&gt;
  &lt;li&gt;To "append" items into a list&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Moving to Phase Two</title>
    <link rel="alternate" href="http://blog.url.com/modules/module07-phasetwo.html"/>
    <id>http://blog.url.com/modules/module07-phasetwo.html</id>
    <published>2014-09-18T20:00:00-04:00</published>
    <updated>2014-10-11T16:17:52-04:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;At the half-way point, it is stop briefly and think through what we have already learned. So far, you have learned to talk to your computer using the terminal. You've interacted with Python, a programming language and used Python to execute a few commands. You've also learned how to use Pip to add additional libraries to Python, and thought about using libraries like lego blocks or cake mix to create new programs. &lt;/p&gt;

&lt;p&gt;You've also learned about data and APIs. We looked at JSON as a way of structuring data and thought about what it means to represent things in this format. Then, we looked at the DPLA api and learned how to leverage libraries like DPyLA to use those APIs in our code. Finally, we saved our code in a python file that we learned how to execute in the terminal.&lt;/p&gt;

&lt;p&gt;Well Done!&lt;/p&gt;

&lt;p&gt;So far you have been writing code that does one thing: it get search results or prints a particular item. The power of code, however, is being able to do the same thing to a series of items and it is thinking in terms of iterating through a series that is at the core of computational thinking. To do this, we will learn two very powerful programming concepts: functions and loops.&lt;/p&gt;

&lt;h3 id="asking-questions-of-our-data"&gt;Asking Questions of Our Data&lt;/h3&gt;

&lt;p&gt;We have been able to do a lot with filtering the data by subject headings, by geographic space, and by contributor. But what if we want to ask questions about how the materials are described across all 10,000+ items associated with "cooking"? Say we are interested in how those descriptions of items related to cooking are gendered. How would we investigate patterns across the entirety of the DPLA's holdings related to "cooking"?&lt;/p&gt;

&lt;p&gt;There are many ways one could go about investigating the descriptions. Work with your table to brain-storm a couple of approaches.&lt;/p&gt;

&lt;h3 id="adding-parameters-to-the-query"&gt;Adding Parameters to the Query&lt;/h3&gt;

&lt;p&gt;To start, we need to restructure our query so that we can control the number of items and the "page" we get the data from. Remember that the API by default gives us 10 items at a time. We can pass a variable to get up to 500 items at a time, but there were 10,909 items associated with "cooking".&lt;/p&gt;

&lt;p&gt;Open your "my_first_script.py" file. Looking at the line that says &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;result = dpla.search('cooking')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we can change the number of items we get back by adding an additional parameter to what we pass to dpla.search. Looking at the documentation, we learn that the syntax for setting the number of items is &lt;span class="command"&gt;page_size=&lt;/span&gt; and the number of items we want. To get 50 items rather than 10, change that line to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;result = dpla.search('cooking', page_size=50)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To check that this worked, let's add a line telling the computer to print out the 40th item:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print result.items[39]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remember, counting within a list begins at 0.&lt;/p&gt;

&lt;p&gt;Use the &lt;a href="https://github.com/bibliotechy/DPyLA"&gt;documentation&lt;/a&gt; and your table to add another parameter to get the information from page 3.&lt;/p&gt;

&lt;h3 id="setting-up-a-variable"&gt;Setting Up a Variable&lt;/h3&gt;

&lt;p&gt;To get all 10,000+ items associated with cooking, we need to do two things: we need to get the items all of the pages and we need a place to store them, so that as we get new items, our collections grows.&lt;/p&gt;

&lt;p&gt;Let's tackle the second problem first. Remember back to variables? Variables are names we used to hold values. We can also use variables to hold lists. For example, I could create a list "fruit" that has the values "apple, orange, banana" by doing the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fruit = ["apple", "orange", "banana"]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;now if I ask for the second item in fruit&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fruit[1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I will get back "orange".&lt;/p&gt;

&lt;p&gt;We are going to use a similar structure to save all of the items we get back from the DPLA.&lt;/p&gt;

&lt;p&gt;Go back to "my_first_script.py". Comment out the line &lt;span class="command"&gt;result = dpla.search('cooking', page_size=50)&lt;/span&gt; by placing a # sign at the front of the line. This tells the computer to skip this line. Also comment out the line you wrote to print out one of the items.&lt;/p&gt;

&lt;p&gt;Your file should look something like this: &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from dpla.api import DPLA

dpla = DPLA('YourKeyHere')

# result = dpla.search('cooking')
# print result.items[1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, let's create a new variable, "all_records" and set it equal to an empty list.&lt;/p&gt;

&lt;p&gt;To do this, add a new line:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;all_records = []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This tells the computer that we have a variable, "all_records", that this variable will hold a list, and that we currently have no items in that list.&lt;/p&gt;

&lt;p&gt;Now that we have a place to store our values, we now have to tell the computer to get the search results from each page and save those results to the "all_records" list.&lt;/p&gt;

&lt;h3 id="what-we-learned"&gt;What We Learned&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;To add additional parameters to our API call&lt;/li&gt;
  &lt;li&gt;To create an empty list&lt;/li&gt;
  &lt;li&gt;To comment-out code that we don't want to run, but want to keep&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Write Python in Script Files</title>
    <link rel="alternate" href="http://blog.url.com/modules/module06-use_editor.html"/>
    <id>http://blog.url.com/modules/module06-use_editor.html</id>
    <published>2014-09-18T20:00:00-04:00</published>
    <updated>2014-10-11T10:46:54-04:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;In this module, we will look at how to keep save our Python scripts in a text file. While the Interactive Shell is really useful for figuring things out, files are easier to share and enable us to keep our save our work as we go.&lt;/p&gt;

&lt;h3 id="writing-and-executing-script-files"&gt;Writing and Executing Script Files&lt;/h3&gt;

&lt;p&gt;First, exit out of the Python Interactive Shell by running &lt;span class="command"&gt;exit()&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;You should still be in the folder we made at the beginning of the day. Check using &lt;span class="command"&gt;pwd&lt;/span&gt;. &lt;/p&gt;

&lt;p&gt;Now remember we created a file called "my_first_script.py"? Let's open that file again and remind ourselves of what we wrote.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open my_first_script.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It should say 'print "Hello World"'. Now that you know something about Python functions, what do you expect this script to do?&lt;/p&gt;

&lt;p&gt;Let's test it out! To execute a Python file, run the following in terminal:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python my_first_script.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Your terminal window should look something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jeriwieringa$ python my_first_script.py
Hello World
jeriwieringa$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Excellent! You just executed your first Python script!&lt;/p&gt;

&lt;h3 id="writing-our-dpyla-script"&gt;Writing our DPyLA Script&lt;/h3&gt;

&lt;p&gt;Now let's recreate some of the work we did in the Interactive Shell in this script file.&lt;/p&gt;

&lt;p&gt;Delete &lt;span class="command"&gt;print "Hello World"&lt;/span&gt; so that you're working with a clean file. &lt;/p&gt;

&lt;p&gt;First, at the beginning of a Python file you need to list the libraries that we will be using. Similar to HTML, the computer will execute the code in the order it reads it, so it is important that your commands follow a logical structure down the page. &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from dpla.api import DPLA
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we need to store our API key:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dpla = DPLA('YourAPIKey')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we can write our search query:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;result = dpla.search('cooking')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Save the file and go back to Terminal. Run &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;python my_first_script.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You should notice that your computer works for awhile and then returns to normal, but doesn't tell you anything about what it did. To see results, we can use the print function again.&lt;/p&gt;

&lt;p&gt;Open your script file again (&lt;span class="command"&gt;open my_first_script.py&lt;/span&gt;). &lt;/p&gt;

&lt;p&gt;Work with your group to add another line to the file that uses the print function to display one item from your search. &lt;/p&gt;

&lt;p&gt;Print is a very useful tool for checking on your script as it moves through your commands. You can use "print" to make sure your query is returning what you wanted, that your code is parsing as you expect, and to identify where things go wrong. &lt;/p&gt;

&lt;h3 id="what-weve-learned"&gt;What We've Learned&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;To execute Python scripts in the Terminal&lt;/li&gt;
  &lt;li&gt;To write our commands in the order they should be executed&lt;/li&gt;
  &lt;li&gt;To use print to display the results of our scripts&lt;/li&gt;
&lt;/ul&gt;

</content>
  </entry>
  <entry>
    <title>Working with the API</title>
    <link rel="alternate" href="http://blog.url.com/modules/module05-complex_requests.html"/>
    <id>http://blog.url.com/modules/module05-complex_requests.html</id>
    <published>2014-09-18T20:00:00-04:00</published>
    <updated>2014-10-06T23:55:11-04:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;Now that we've learned to make a simple request using the DPyLA library, let's spend some time exploring the different kinds of requests we can make. &lt;/p&gt;

&lt;h3 id="constructing-api-requests"&gt;Constructing API Requests&lt;/h3&gt;

&lt;p&gt;Open up the &lt;a href="https://github.com/bibliotechy/DPyLA"&gt;documentation for the DPyLA library&lt;/a&gt; and for the &lt;a href="http://dp.la/info/developers/codex/requests/"&gt;DPLA API&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;First, let's get some contextual data about the search results. Run &lt;span class="command"&gt;result.count&lt;/span&gt;. This tells you how many items total fit the search term. &lt;/p&gt;

&lt;p&gt;Now run &lt;span class="command"&gt;result.limit&lt;/span&gt;. This tells you how many results the API returned. By default, the API will give you 10 results at a time. Look at the DPyLA documentation and try to construct a request that gets you 50 results.&lt;/p&gt;

&lt;p&gt;You can also limit your search results by a variety of variables. &lt;/p&gt;

&lt;p&gt;For example, you can sort by geography:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;result = dpla.search("cooking", spatial_facet=[37.7577,-122.4376])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also be more specific with your search, such as limiting your query to cooking in the title of an item. &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;result = dpla.search("cooking", fields=["sourceResource:title"])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These types of commands help you focus the search results so that you have less noisy data - so that more of the data fits the questions you want to ask.&lt;/p&gt;

&lt;p&gt;Work with the documentation and your table to construct some more targeted queries. &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;In what ways would you want to narrow the data for different questions?&lt;/li&gt;
  &lt;li&gt;Do you see any additional strengths or weaknesses with the data when trying to limit your search results?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="what-we-learned"&gt;What we learned&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Reading API documentation to understand the possible queries&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
</feed>
