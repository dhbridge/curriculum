---
title: Analyzing a Subset of the Data (Part 2)
date: 2014-09-19
---

In this module we will learn to:

1. normalize our text
2. use the Frequency Distribution library to find pattern in our text 

### Normalizing the text

While we can get a lot of information from all of the text, we can also find additional patterns once we do what is called 'normalizing' the text. This entails removing all of the punctuation marks, and transforming all the words to lower case. It also involves removing the small, connection words such as 'the' and 'a', which are very common in a text, but carry less semantic meaning than nouns, verbs, and adjectives.

To clean up the text, we need to work through each words and and run it through a series of checks or filters. 

Open your 'text_mining.py' file. First, comment out <span class="command">print text.similar('Pot')</span>. Next, let's create a new function that normalizes the text:

    import nltk
    from nltk.corpus import stopwords
    from nltk import word_tokenize

    with open('text_results.txt') as file:
        cooking_text = file.read()
    # print cooking_text[0:20]

    cooking_tokens = word_tokenize(cooking_text)
    # print cooking_tokens[0:10]

    text = nltk.Text(cooking_tokens)

    #print text[:20]
    #print text.concordance('economy')
    #print text.collocations()

    # print text.similar('Pot')

    def normalize_text(text):
        # Work through all the words in text and filter

To work through the words, we can use a new 'for loop' and save all of the approved words into a new array. Create your new array above your 'normalize_text' function.
    
    word_set = []

    def normalize_text(text):
        # Work through all the words in text and filter
        for word in text:
            # Create list of words
            

First, for each word, let's check if it is alpha-numeric:

    word_set = []

    def normalize_text(text):
        # Work through all the words in text and filter
        for word in text:
            # Check if word is a word, and not punctuation
            if word.isalpha()

Next, let's check the word against the NLTK collection of stopwords. First, let's load in the NLTK stopwords and assign them to the variable 'stopwords':

    import nltk
    from nltk.corpus import stopwords
    from nltk import word_tokenize
    
    with open('text_results.txt') as file:
        cooking_text = file.read()
    # print cooking_text[0:20]

    cooking_tokens = word_tokenize(cooking_text)
    # print cooking_tokens[0:10]
    
    # Load in Stopwords Library
    stopwords = stopwords.words('english')

Next, we need to transform each word to lower-case, because the stopwords list won't catch the uppercase words. We do this by adding <span class="command">.lower()</span> to word as we check the words against the 'stopwords' collection. 

    word_set = []

    def normalize_text(text):
        # Work through all the words in text and filter
        for word in text:
            # Check if word is a word, and not punctuation, AND check against stop words
            if word.isalpha() and word.lower() not in stopwords:
                # If it passes the filters, save to word_set

Finally, we will add those words that pass through the filters to the 'word_set' list and tell the function to return to us the whole list once it is finished.

    word_set = []

    def normalize_text(text):
        # Work through all the words in text and filter
        for word in text:
            # Check if word is a word, and not punctuation, AND check against stop words
            if word.isalpha() and word.lower() not in stopwords:
                # If it passes the filters, save to word_set
                word_set.append(word.lower())
        return word_set

The last step is to call our 'normalize_text' function and pass in our text.

    def normalize_text(text):
        # Work through all the words in text and filter
        for word in text:
            # Check if word is a word, and not punctuation, AND check against stop words
            if word.isalpha() and word.lower() not in stopwords:
                # If it passes the filters, save to word_set
                word_set.append(word.lower())
        return word_set

    normalize_text(text)

Well done! We're now ready to calculate word frequencies using the Frequency Distribution library.

### Get Word Frequencies

Our python file should now look like this: 

    import nltk
    from nltk.corpus import stopwords
    from nltk import word_tokenize
    
    with open('text_results.txt') as file:
        cooking_text = file.read()
    # print cooking_text[0:20]

    cooking_tokens = word_tokenize(cooking_text)
    # print cooking_tokens[0:10]
    
    # Load in Stopwords Library
    stopwords = stopwords.words('english')

    text = nltk.Text(cooking_tokens)

    #print text[:20]
    #print text.concordance('economy')
    #print text.collocations()

    # print text.similar('Pot')

    def normalize_text(text):
        # Work through all the words in text and filter
        for word in text:
            # Check if word is a word, and not punctuation, AND check against stop words
            if word.isalpha() and word.lower() not in stopwords:
                # If it passes the filters, save to word_set
                word_set.append(word.lower())
        return word_set

    normalize_text(text)

We need one more library to get word frequencies from our array of approved words. After <span class="command">from nltk import word_tokenize</span>, add:

    from nltk.probability import *

Now, we will use the Frequency Distribution library to get word counts. This may seem a bit like magic, and that is ok. NLTK is a very powerful library, and by using it, we can draw on the work others to build and verify that the functions do what they say they do. There is no need to reinvent the wheel with every new script.

The first step is to create a new variable and use that to hold the results of calling the frequency distribution function. After <span>normalize_text(text)</span> add:

    fd = FreqDist(word_set)

Frequency Distribution goes through all off the words in our array and create a dictionary that holds the word, and the number of times it occurs in our document.

To see the 50 most common words, add to the bottom of the file:

    print fd.most_common(50)

to your script and run. You should start to see some magic happening in the termainal.

You can also see the words that only occur once by adding to the bottom of the file:

    print fd.hapaxes()

and running the 'text_mining.py' script.

And, for some super magic, you can also generate a plot with:

    fd.plot(50,cumulative=False)

You can comment out print statements along the way if you are seeing too much information. Save your script and run it in the terminal.

### Bonus Challenge

You can also use "stemming" to combine multipe forms of the same word, such as "photograph" and "photographs". Can you use the [NLTK documentation](http://www.nltk.org/api/nltk.stem.html) to add another filter that stems the words before adding them to 'word_set'?


<span class="left">[Previous Module](module11.html)</span>
<span class="right">[Next Module](module13.html)</span>
