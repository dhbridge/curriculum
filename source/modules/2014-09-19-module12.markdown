---
title: Analyzing a Subset of the Data (Part 2)
date: 2014-09-19
---

In this module we will learn to:

1. normalize our text
2. use the Frequency Distribution library to find pattern in our text 

### Normalizing the text

While we can get a lot of information from all of the text, we can also find additional patterns once we do what is called 'normalizing' the text. This entails removing all of the punctuation marks, and transforming all the words to lower case. It also involves removing the small, connection words such as 'the' and 'a', which are very common in a text, but carry less semantic meaning than nouns, verbs, and adjectives.

To clean up the text, we need to work through each words and and run it through a series of checks or filters. 

Open your 'text_mining.py' file. First, comment out <span class="command">print text.similar('Pot')</span>. Next, let's create a new function that normalizes the text:

    # Import Libraries
    import nltk
    from nltk.corpus import stopwords
    from nltk import word_tokenize

    # Set Variables
    with open('text_results.txt', 'r') as file:
        cooking_text = file.read().decode('utf8')

    cooking_tokens = word_tokenize(cooking_text)
    text = nltk.Text(cooking_tokens)

    # Define Functions
    def normalize_text(text):
        # Work through all the words in text and filter

    # Make Function Calls
    #print cooking_text[0:20]
    #print cooking_tokens[0:10]
    #print text.concordance('economy')
    #print text.collocations()
    #print text.similar('Pot')

To work through the words, we can use a new 'for loop' and save all of the approved words into a new array. Create your new array at the end of the 'Define Variables' section.
    
    word_set = []

    # Define Functions
    def normalize_text(text):
        # Work through all the words in text and filter
        for word in text:
            # Create list of words
            
First, for each word, let's check if it is alpha-numeric:

    word_set = []

    # Define Functions
    def normalize_text(text):
        # Work through all the words in text and filter
        for word in text:
            # Check if word is a word, and not punctuation
            if word.isalpha()

Next, let's check the word against the NLTK collection of stopwords. First, let's load in the NLTK stopwords and assign them to the variable 'stopwords':

    # Import Libraries
    import nltk
    from nltk.corpus import stopwords
    from nltk import word_tokenize

    # Set Variables
    with open('text_results.txt', 'r') as file:
        cooking_text = file.read().decode('utf8')

    cooking_tokens = word_tokenize(cooking_text)
    text = nltk.Text(cooking_tokens)
    
    # Load in Stopwords Library
    stopwords = stopwords.words('english')

    word_set = []

Next, we need to transform each word to lower-case, because the stopwords list won't catch the uppercase words. We do this by adding <span class="command">.lower()</span> to word as we check the words against the 'stopwords' collection. 

    word_set = []

    # Define Functions
    def normalize_text(text):
        # Work through all the words in text and filter
        for word in text:
            # Check if word is a word, and not punctuation, AND check against stop words
            if word.isalpha() and word.lower() not in stopwords:
                # If it passes the filters, save to word_set

Finally, we will add those words that pass through the filters to the 'word_set' list and tell the function to return to us the whole list once it is finished.

    word_set = []

    # Define Functions
    def normalize_text(text):
        # Work through all the words in text and filter
        for word in text:
            # Check if word is a word, and not punctuation, AND check against stop words
            if word.isalpha() and word.lower() not in stopwords:
                # If it passes the filters, save to word_set
                word_set.append(word.lower())
        return word_set

The last step is to call our 'normalize_text' function and pass in our text.

    # Define Functions
    def normalize_text(text):
        # Work through all the words in text and filter
        for word in text:
            # Check if word is a word, and not punctuation, AND check against stop words
            if word.isalpha() and word.lower() not in stopwords:
                # If it passes the filters, save to word_set
                word_set.append(word.lower())
        return word_set

    # Make Function Calls
    #print cooking_text[0:20]
    #print cooking_tokens[0:10]
    #print text.concordance('economy')
    #print text.collocations()
    #print text.similar('Pot')

    normalize_text(text)

Well done! We're now ready to calculate word frequencies using the Frequency Distribution library.

### Get Word Frequencies

Our python file should now look like this: 

    # Import Libraries
    import nltk
    from nltk.corpus import stopwords
    from nltk import word_tokenize

    # Set Variables
    with open('text_results.txt', 'r') as file:
        cooking_text = file.read().decode('utf8')

    cooking_tokens = word_tokenize(cooking_text)
    text = nltk.Text(cooking_tokens)
    
    # Load in Stopwords Library
    stopwords = stopwords.words('english')

    word_set = []

    # Define Functions
    def normalize_text(text):
        # Work through all the words in text and filter
        for word in text:
            # Check if word is a word, and not punctuation, AND check against stop words
            if word.isalpha() and word.lower() not in stopwords:
                # If it passes the filters, save to word_set
                word_set.append(word.lower())
        return word_set

    # Make Function Calls
    #print cooking_text[0:20]
    #print cooking_tokens[0:10]
    #print text.concordance('economy')
    #print text.collocations()
    #print text.similar('Pot')
    
    normalize_text(text)

We need one more library to get word frequencies from our array of approved words. After <span class="command">from nltk import word_tokenize</span>, add:

    from nltk.probability import *

Now, we will use the Frequency Distribution library to get word counts. This may seem a bit like magic, and that is ok. NLTK is a very powerful library, and by using it, we can draw on the work others to build and verify that the functions do what they say they do. There is no need to reinvent the wheel with every new script.

The first step is to run the frequency distribution function and save the results to a variable to make them easier to use. After <span>normalize_text(text)</span> add:

    fd = FreqDist(word_set)

Frequency Distribution goes through all of the words in our array and creates a dictionary that holds the word, and the number of times it occurs in our document. 

To see the 200 most common words, add to the bottom of the 'Make Function Calls' section:

    print fd.most_common(200)

Your file should look like:

    # Import Libraries
    import nltk
    from nltk.corpus import stopwords
    from nltk import word_tokenize
    from nltk.probability import *

    # Set Variables
    with open('text_results.txt', 'r') as file:
        cooking_text = file.read().decode('utf8')

    cooking_tokens = word_tokenize(cooking_text)
    text = nltk.Text(cooking_tokens)
    
    # Load in Stopwords Library
    stopwords = stopwords.words('english')

    word_set = []

    # Define Functions
    def normalize_text(text):
        # Work through all the words in text and filter
        for word in text:
            # Check if word is a word, and not punctuation, AND check against stop words
            if word.isalpha() and word.lower() not in stopwords:
                # If it passes the filters, save to word_set
                word_set.append(word.lower())
        return word_set

    # Make Function Calls
    #print cooking_text[0:20]
    #print cooking_tokens[0:10]
    #print text.concordance('economy')
    #print text.collocations()
    #print text.similar('Pot')

    normalize_text(text)

    fd = FreqDist(word_set) 
    print fd.most_common(200)

Save your script and run. You should start to see some magic happening in the termainal.

And, for some super magic, you can also generate a plot with:

    fd.plot(50,cumulative=False)

You can comment out print statements along the way if you are seeing too much information. Save your script and run it in the terminal.


<span class="left">[Previous Module](module11.html)</span>
<span class="right">[Next Module](module13.html)</span>
